{"ast":null,"code":"/**\r\n * Module, defining Axis Renderer for curved axes.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\nimport { WavedCircle } from \"../../core/elements/WavedCircle\";\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $type from \"../../core/utils/Type\";\nimport { AxisBullet } from \"../../charts/axes/AxisBullet\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A renderer for radial axis.\r\n */\n\nvar AxisRendererCurveY =\n/** @class */\nfunction (_super) {\n  __extends(AxisRendererCurveY, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param axis Related axis\r\n   */\n\n\n  function AxisRendererCurveY() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A related chart.\r\n     */\n\n\n    _this._chart = new MutableValueDisposer();\n    _this.className = \"AxisRendererCurveY\";\n    _this.isMeasured = false;\n    _this.minGridDistance = 30;\n    _this.isMeasured = false;\n    _this.layout = \"none\";\n    _this.radius = 40;\n    _this.innerRadius = -40;\n    _this.line.strokeOpacity = 0;\n    _this.labels.template.horizontalCenter = \"right\";\n\n    _this._disposers.push(_this._chart);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Validates Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCurveY.prototype.validate = function () {\n    // so that radius would be updated\n    if (this.chart && this.chart.invalid) {\n      this.chart.validate();\n    }\n\n    _super.prototype.validate.call(this);\n  };\n\n  Object.defineProperty(AxisRendererCurveY.prototype, \"axisLength\", {\n    /**\r\n     * Actual length of the Axis, in pixels.\r\n     *\r\n     * @return Length (px)\r\n     */\n    get: function get() {\n      return Math.abs(this.radius - this.innerRadius);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCurveY.prototype, \"radius\", {\n    /**\r\n     * @return Outer radius\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"radius\");\n    },\n\n    /**\r\n     * Outer radius of the vertical (Y) axis in pixels.\r\n     *\r\n     * Indicate distance from the charts X axis control curve.\r\n     *\r\n     * Negative number means inside/below the X axis.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/timeline/#Axis_radii} for more info\r\n     * @param value  Outer radius\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"radius\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCurveY.prototype, \"innerRadius\", {\n    /**\r\n     * @return Inner radius\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"innerRadius\");\n    },\n\n    /**\r\n     * Inner radius of the vertical (Y) axis in pixels.\r\n     *\r\n     * Indicate distance from the charts X axis control curve.\r\n     *\r\n     * Negative number means inside/below the X axis.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/timeline/#Axis_radii} for more info\r\n     * @param value  Outer radius\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"innerRadius\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCurveY.prototype, \"chart\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Chart\r\n     */\n    get: function get() {\n      return this._chart.get();\n    },\n\n    /**\r\n     * Chart, associated with the Axis.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value Chart\r\n     */\n    set: function set(chart) {\n      this._chart.set(chart, null);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position on axis to point coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Point\r\n   */\n\n  AxisRendererCurveY.prototype.positionToPoint = function (position) {\n    return {\n      x: 0,\n      y: this.positionToCoordinate(position)\n    };\n  };\n  /**\r\n   * Updates and positions the axis line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateAxisLine = function () {\n    var axisRendererX = this.axisRendererX;\n\n    if (axisRendererX) {\n      var axis = axisRendererX.axis;\n      var point = axisRendererX.positionToPoint(axis.start + (axis.end - axis.start) * this.axisLocation);\n      var angle = point.angle;\n      var radius = -this.radius;\n      var innerRadius = -this.innerRadius;\n      this.line.path = $path.moveTo({\n        x: innerRadius * $math.cos(angle),\n        y: innerRadius * $math.sin(angle)\n      }) + $path.lineTo({\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      });\n      this.line.moveTo(point);\n      var title = this.axis.title;\n      title.moveTo({\n        x: point.x + radius / 2 * $math.cos(angle),\n        y: point.y + radius / 2 * $math.sin(angle)\n      });\n      title.rotation = angle - 180;\n    }\n  };\n  /**\r\n   * Updates and positions a grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param grid         Grid element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateGridElement = function (grid, position, endPosition) {\n    var axisRendererX = this.axisRendererX;\n\n    if (axisRendererX) {\n      position = position + (endPosition - position) * grid.location;\n\n      if (position >= 0 && position <= 1) {\n        grid.path = this.getGridPath(position);\n      }\n\n      this.positionItem(grid, {\n        x: 0,\n        y: 0\n      });\n      this.toggleVisibility(grid, position, 0, 1);\n    }\n  };\n  /**\r\n   * [getGridPath description]\r\n   *\r\n   * @ignore\r\n   * @todo description\r\n   * @param   position  Position\r\n   * @return            SVG path\r\n   */\n\n\n  AxisRendererCurveY.prototype.getGridPath = function (position) {\n    var axisRendererX = this.axisRendererX;\n    var path = \"\";\n\n    if (axisRendererX && $type.isNumber(position)) {\n      var radius = $math.round(this.positionToPoint(position).y, 1);\n      var point = axisRendererX.positionToPoint(axisRendererX.axis.start);\n      var angle = point.angle;\n      var count = Math.ceil(axisRendererX.axisLength / axisRendererX.precisionStep);\n      var start = axisRendererX.axis.start;\n      var end = axisRendererX.axis.end;\n\n      for (var i = 0; i <= count; i++) {\n        var pos = start + i / count * (end - start);\n        point = axisRendererX.positionToPoint(pos);\n        angle = point.angle;\n        var x = point.x + radius * $math.cos(angle);\n        var y = point.y + radius * $math.sin(angle);\n        path += $path.lineTo({\n          x: x,\n          y: y\n        });\n      }\n\n      path = path.replace(\"L\", \"M\");\n    }\n\n    return path;\n  };\n  /**\r\n   * Updates and positions a label element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param label        Label element\r\n   * @param position     Starting position\r\n   * @param endPosition  Ending position\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateLabelElement = function (label, position, endPosition, location) {\n    if (!$type.hasValue(location)) {\n      location = label.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    var radius = this.positionToPoint(position).y;\n    var axisRendererX = this.axisRendererX;\n\n    if (axisRendererX) {\n      var axis = axisRendererX.axis;\n      var point = axisRendererX.positionToPoint(axis.start + (axis.end - axis.start) * this.axisLocation);\n      var angle = point.angle;\n      point.x += radius * $math.cos(angle);\n      point.y += radius * $math.sin(angle);\n      this.positionItem(label, point);\n      this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\n    }\n  };\n  /**\r\n   * Updates and positions a tick element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param tick      Tick element\r\n   * @param position  Position\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateTickElement = function (tick, position) {\n    if (tick.element) {\n      var axisRendererX = this.axisRendererX;\n\n      if (axisRendererX) {\n        var point = axisRendererX.positionToPoint(this.axisLocation);\n        var angle = point.angle;\n        var radius = this.positionToPoint(position).y;\n        point.x += radius * $math.cos(angle);\n        point.y += radius * $math.sin(angle);\n        angle = $math.normalizeAngle(angle + 90);\n\n        if (angle / 90 != Math.round(angle / 90)) {\n          tick.pixelPerfect = false;\n        } else {\n          tick.pixelPerfect = true;\n        }\n\n        var tickLength = tick.length;\n\n        if (tick.inside) {\n          tickLength *= -1;\n        }\n\n        tick.path = $path.moveTo({\n          x: 0,\n          y: 0\n        }) + $path.lineTo({\n          x: tickLength * $math.cos(angle),\n          y: tickLength * $math.sin(angle)\n        });\n        this.positionItem(tick, point);\n        this.toggleVisibility(tick, position, 0, 1);\n      }\n    }\n  };\n  /**\r\n   * Updates and positions axis bullet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param bullet       AxisBullet element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateBullet = function (bullet, position, endPosition) {\n    var location = 0.5;\n\n    if (bullet instanceof AxisBullet) {\n      location = bullet.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    var axisRendererX = this.axisRendererX;\n\n    if (axisRendererX) {\n      var point = axisRendererX.positionToPoint(this.axisLocation);\n      var angle = point.angle;\n      var radius = this.positionToPoint(position).y;\n      point.x += radius * $math.cos(angle);\n      point.y += radius * $math.sin(angle);\n      angle = $math.normalizeAngle(angle + 90);\n      this.positionItem(bullet, point);\n      this.toggleVisibility(bullet, position, 0, 1);\n    }\n  };\n  /**\r\n   * Updates and positions the base grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateBaseGridElement = function () {// @todo? zero grid for curve chart, is it needed?\n  };\n  /**\r\n   * Checks if point is within bounds of a container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param point Point coordinates\r\n   * @return Fits?\r\n   */\n\n\n  AxisRendererCurveY.prototype.fitsToBounds = function (point) {\n    return true;\n  };\n  /**\r\n   * [getPositionRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param startPosition  Starting position\r\n   * @param endPosition    End position\r\n   * @return SVG path\r\n   */\n\n\n  AxisRendererCurveY.prototype.getPositionRangePath = function (startPosition, endPosition) {\n    var path = \"\";\n    var axisRendererX = this.axisRendererX;\n\n    if (axisRendererX) {\n      var startX = axisRendererX.axis.start;\n      var endX = axisRendererX.axis.end;\n      var startY = this.axis.start;\n      var endY = this.axis.end;\n\n      if (startPosition <= startY && endPosition <= startY || startPosition >= endY && endPosition >= endY) {\n        return path;\n      }\n\n      startPosition = $math.fitToRange(startPosition, startY, endY);\n      endPosition = $math.fitToRange(endPosition, startY, endY);\n      var startRadius = $math.round(this.positionToPoint(startPosition).y, 1);\n      var endRadius = $math.round(this.positionToPoint(endPosition).y, 1);\n\n      if ($type.isNaN(startRadius) || $type.isNaN(endRadius)) {\n        return \"\";\n      }\n\n      var point = axisRendererX.positionToPoint(startX);\n      var angle = point.angle;\n      path = $path.moveTo(point);\n      var count = Math.ceil(axisRendererX.axisLength / axisRendererX.precisionStep);\n\n      for (var i = 0; i <= count; i++) {\n        var pos = startX + i / count * (endX - startX);\n        point = axisRendererX.positionToPoint(pos);\n        angle = point.angle;\n        var x = point.x + startRadius * $math.cos(angle);\n        var y = point.y + startRadius * $math.sin(angle);\n        path += $path.lineTo({\n          x: x,\n          y: y\n        });\n      }\n\n      for (var i = count; i >= 0; i--) {\n        var pos = startX + i / count * (endX - startX);\n        point = axisRendererX.positionToPoint(pos);\n        angle = point.angle;\n        var x = point.x + endRadius * $math.cos(angle);\n        var y = point.y + endRadius * $math.sin(angle);\n        path += $path.lineTo({\n          x: x,\n          y: y\n        });\n      }\n\n      path += $path.closePath();\n    }\n\n    return path;\n  };\n  /**\r\n   * Updates and positions an axis break element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Break element\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateBreakElement = function (axisBreak) {\n    var axisRendererX = this.axisRendererX;\n\n    if (axisRendererX) {\n      axisBreak.fillShape.path = this.getPositionRangePath(axisBreak.startPosition, axisBreak.endPosition);\n      this.toggleVisibility(axisBreak.startLine, axisBreak.startPosition, 0, 1);\n      this.toggleVisibility(axisBreak.endLine, axisBreak.endPosition, 0, 1);\n    }\n  };\n  /**\r\n   * Creates visual elements for and axis break.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Axis break\r\n   */\n\n\n  AxisRendererCurveY.prototype.createBreakSprites = function (axisBreak) {\n    axisBreak.startLine = new WavedCircle();\n    axisBreak.endLine = new WavedCircle();\n    axisBreak.fillShape = new WavedCircle();\n  };\n  /**\r\n   * Updates some of the Axis tooltip's visual properties, related to\r\n   * rendering of the Axis.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCurveY.prototype.updateTooltip = function () {\n    var axis = this.axis;\n\n    if (axis) {\n      /*\r\n      let bigNum: number = 4000;\r\n      let bbx: number = -4000;\r\n      let bby: number = -4000;\r\n      let bbw: number = bigNum * 2;\r\n      let bbh: number = bigNum * 2;\r\n        this.axis.updateTooltip(tooltipOrientation, { x: bbx, y: bby, width: bbw, height: bbh }); */\n    }\n  };\n  /**\r\n   * Converts a position on the axis to a coordinate in pixels.\r\n   *\r\n   * @param  position  Position (0-1)\r\n   * @return           Coordinate (px)\r\n   */\n\n\n  AxisRendererCurveY.prototype.positionToCoordinate = function (position) {\n    var coordinate;\n    var axis = this.axis;\n    var axisFullLength = axis.axisFullLength;\n\n    if (axis.renderer.inversed) {\n      coordinate = (axis.end - position) * axisFullLength;\n    } else {\n      coordinate = (position - axis.start) * axisFullLength;\n    }\n\n    return $math.round(-this.innerRadius - coordinate, 4);\n  };\n\n  Object.defineProperty(AxisRendererCurveY.prototype, \"axisLocation\", {\n    /**\r\n     * @return Axis location\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"axisLocation\");\n    },\n    // TODO: make this universal?\n\n    /**\r\n     * Relative location of the Y axis along the length of the X axis.\r\n     *\r\n     * Values range from 0 (default) which means start of the X axis, to 1 meaning\r\n     * end of the X axis.\r\n     *\r\n     * @default 0\r\n     * @param  value  Axis location\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"axisLocation\", value);\n      this.invalidateAxisItems();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Called when rendered is attached to an Axis, as well as a property of\r\n   * Axis that might affect the appearance is updated.\r\n   *\r\n   * E.g. `axis.opposite`, `axis.inside`, etc.\r\n   *\r\n   * This method is called **before** draw, so that any related setting\r\n   * changed in this method can be changed.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n\n  AxisRendererCurveY.prototype.processRenderer = function () {\n    _super.prototype.processRenderer.call(this); // can not do this in init, as axis is set later\n\n\n    var axis = this.axis;\n\n    if (axis) {\n      var title = axis.title;\n\n      if (title) {\n        title.isMeasured = false;\n        title.horizontalCenter = \"middle\";\n        title.verticalCenter = \"bottom\";\n      }\n    }\n  };\n  /**\r\n   * Converts a coordinate in pixels to a relative position. (0-1)\r\n   *\r\n   * @param coordinate  Coordinate (px)\r\n   * @param coordinate2  Coordinate (px) Some more complicated axes need two coordinates\r\n   * @return Position (0-1)\r\n   */\n\n\n  AxisRendererCurveY.prototype.coordinateToPosition = function (coordinate, coordinate2) {\n    var axisRendererX = this.axisRendererX;\n    var distance = coordinate;\n\n    if (axisRendererX) {\n      var closestPoint = axisRendererX.polyspline.allPoints[axisRendererX.polyspline.getClosestPointIndex({\n        x: coordinate2,\n        y: coordinate\n      })];\n      var angle = closestPoint.angle - 90;\n      distance = $math.getDistance({\n        x: closestPoint.x + this.innerRadius * $math.cos(angle),\n        y: closestPoint.y + this.innerRadius * $math.sin(angle)\n      }, {\n        x: coordinate2,\n        y: coordinate\n      });\n    }\n\n    return _super.prototype.coordinateToPosition.call(this, distance);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  AxisRendererCurveY.prototype.toAxisPosition = function (value) {\n    return value;\n  };\n\n  return AxisRendererCurveY;\n}(AxisRendererY);\n\nexport { AxisRendererCurveY };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisRendererCurveY\"] = AxisRendererCurveY;","map":{"version":3,"sources":["../../../../../src/.internal/plugins/timeline/AxisRendererCurveY.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Module, defining Axis Renderer for curved axes.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisRendererY, IAxisRendererYProperties, IAxisRendererYAdapters, IAxisRendererYEvents } from \"../../charts/axes/AxisRendererY\";\r\nimport { AxisRendererCurveX } from \"./AxisRendererCurveX\";\r\nimport { Axis } from \"../../charts/axes/Axis\";\r\nimport { AxisTick } from \"../../charts/axes/AxisTick\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { Grid } from \"../../charts/axes/Grid\";\r\nimport { AxisBreak } from \"../../charts/axes/AxisBreak\";\r\nimport { WavedCircle } from \"../../core/elements/WavedCircle\";\r\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { CurveChart } from \"./CurveChart\"\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { AxisBullet } from \"../../charts/axes/AxisBullet\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[AxisRendererCurveY]].\r\n */\r\nexport interface IAxisRendererCurveYProperties extends IAxisRendererYProperties {\r\n\r\n\t/**\r\n\t * Outer radius of the vertical (Y) axis in pixels.\r\n\t *\r\n\t * Indicate distance from the charts X axis control curve.\r\n\t */\r\n\tradius?: number;\r\n\r\n\t/**\r\n\t * Inner radius of the vertical (Y) axis in pixels.\r\n\t *\r\n\t * Indicate distance from the charts X axis control curve.\r\n\t */\r\n\tinnerRadius?: number;\r\n\r\n\t/**\r\n\t * Relative location of the Y axis along the length of the X axis.\r\n\t *\r\n\t * Values range from 0 (default) which means start of the X axis, to 1 meaning\r\n\t * end of the X axis.\r\n\t */\r\n\taxisLocation?: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[AxisRendererCurveY]].\r\n */\r\nexport interface IAxisRendererCurveYEvents extends IAxisRendererYEvents { }\r\n\r\n/**\r\n * Defines adapters for [[AxisRenderer]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IAxisRendererCurveYAdapters extends IAxisRendererYAdapters, IAxisRendererCurveYProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A renderer for radial axis.\r\n */\r\nexport class AxisRendererCurveY extends AxisRendererY {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IAxisRendererCurveYProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IAxisRendererCurveYAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IAxisRendererCurveYEvents;\r\n\r\n\t/**\r\n\t * A related chart.\r\n\t */\r\n\tprotected _chart = new MutableValueDisposer<CurveChart>();\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic axisRendererX: AxisRendererCurveX; // @todo automatic\r\n\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t *\r\n\t * @param axis Related axis\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"AxisRendererCurveY\";\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.minGridDistance = 30;\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.layout = \"none\";\r\n\r\n\t\tthis.radius = 40;\r\n\t\tthis.innerRadius = -40;\r\n\r\n\t\tthis.line.strokeOpacity = 0;\r\n\r\n\t\tthis.labels.template.horizontalCenter = \"right\";\r\n\r\n\t\tthis._disposers.push(this._chart);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate() {\r\n\t\t// so that radius would be updated\r\n\t\tif (this.chart && this.chart.invalid) {\r\n\t\t\tthis.chart.validate();\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * Actual length of the Axis, in pixels.\r\n\t *\r\n\t * @return Length (px)\r\n\t */\r\n\tpublic get axisLength(): number {\r\n\t\treturn Math.abs(this.radius - this.innerRadius);\r\n\t}\r\n\r\n\t/**\r\n\t * Outer radius of the vertical (Y) axis in pixels.\r\n\t *\r\n\t * Indicate distance from the charts X axis control curve.\r\n\t *\r\n\t * Negative number means inside/below the X axis.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/timeline/#Axis_radii} for more info\r\n\t * @param value  Outer radius\r\n\t */\r\n\tpublic set radius(value: number) {\r\n\t\tthis.setPropertyValue(\"radius\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Outer radius\r\n\t */\r\n\tpublic get radius(): number {\r\n\t\treturn this.getPropertyValue(\"radius\");\r\n\t}\r\n\r\n\t/**\r\n\t * Inner radius of the vertical (Y) axis in pixels.\r\n\t *\r\n\t * Indicate distance from the charts X axis control curve.\r\n\t *\r\n\t * Negative number means inside/below the X axis.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/timeline/#Axis_radii} for more info\r\n\t * @param value  Outer radius\r\n\t */\r\n\tpublic set innerRadius(value: number) {\r\n\t\tthis.setPropertyValue(\"innerRadius\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Inner radius\r\n\t */\r\n\tpublic get innerRadius(): number {\r\n\t\treturn this.getPropertyValue(\"innerRadius\");\r\n\t}\r\n\r\n\t/**\r\n\t * Chart, associated with the Axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param value Chart\r\n\t */\r\n\tpublic set chart(chart: CurveChart) {\r\n\t\tthis._chart.set(chart, null);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @return Chart\r\n\t */\r\n\tpublic get chart(): CurveChart {\r\n\t\treturn this._chart.get();\r\n\t}\r\n\r\n\t/**\r\n\t * Converts relative position on axis to point coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Point\r\n\t */\r\n\tpublic positionToPoint(position: number): IPoint {\r\n\t\treturn { x: 0, y: this.positionToCoordinate(position) };\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions the axis line element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateAxisLine() {\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\t\tif (axisRendererX) {\r\n\t\t\tlet axis = axisRendererX.axis;\r\n\t\t\tlet point = axisRendererX.positionToPoint(axis.start + (axis.end - axis.start) * this.axisLocation);\r\n\t\t\tlet angle = point.angle;\r\n\r\n\t\t\tlet radius = -this.radius;\r\n\t\t\tlet innerRadius = -this.innerRadius;\r\n\r\n\t\t\tthis.line.path = $path.moveTo({ x: innerRadius * $math.cos(angle), y: innerRadius * $math.sin(angle) }) + $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n\t\t\tthis.line.moveTo(point);\r\n\r\n\t\t\tlet title = this.axis.title;\r\n\t\t\ttitle.moveTo({ x: point.x + radius / 2 * $math.cos(angle), y: point.y + radius / 2 * $math.sin(angle) });\r\n\t\t\ttitle.rotation = angle - 180;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions a grid element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param grid         Grid element\r\n\t * @param position     Starting position\r\n\t * @param endPosition  End position\r\n\t */\r\n\tpublic updateGridElement(grid: Grid, position: number, endPosition: number) {\r\n\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\t\tif (axisRendererX) {\r\n\t\t\tposition = position + (endPosition - position) * grid.location;\r\n\r\n\t\t\tif (position >= 0 && position <= 1) {\r\n\t\t\t\tgrid.path = this.getGridPath(position);\r\n\t\t\t}\r\n\r\n\t\t\tthis.positionItem(grid, { x: 0, y: 0 });\r\n\t\t\tthis.toggleVisibility(grid, position, 0, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [getGridPath description]\r\n\t *\r\n\t * @ignore\r\n\t * @todo description\r\n\t * @param   position  Position\r\n\t * @return            SVG path\r\n\t */\r\n\tpublic getGridPath(position: number): string {\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\t\tlet path = \"\";\r\n\t\tif (axisRendererX && $type.isNumber(position)) {\r\n\r\n\t\t\tlet radius = $math.round(this.positionToPoint(position).y, 1);\r\n\r\n\t\t\tlet point = axisRendererX.positionToPoint(axisRendererX.axis.start);\r\n\t\t\tlet angle = point.angle;\r\n\r\n\t\t\tlet count = Math.ceil(axisRendererX.axisLength / axisRendererX.precisionStep);\r\n\t\t\tlet start = axisRendererX.axis.start;\r\n\t\t\tlet end = axisRendererX.axis.end;\r\n\r\n\t\t\tfor (let i = 0; i <= count; i++) {\r\n\r\n\t\t\t\tlet pos = start + i / count * (end - start);\r\n\t\t\t\tpoint = axisRendererX.positionToPoint(pos);\r\n\t\t\t\tangle = point.angle;\r\n\r\n\t\t\t\tlet x = point.x + radius * $math.cos(angle);\r\n\t\t\t\tlet y = point.y + radius * $math.sin(angle);\r\n\r\n\t\t\t\tpath += $path.lineTo({ x: x, y: y });\r\n\t\t\t}\r\n\r\n\t\t\tpath = path.replace(\"L\", \"M\");\r\n\t\t}\r\n\t\treturn path;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions a label element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param label        Label element\r\n\t * @param position     Starting position\r\n\t * @param endPosition  Ending position\r\n\t */\r\n\tpublic updateLabelElement(label: this[\"_labelType\"], position: number, endPosition: number, location?: number) {\r\n\t\tif (!$type.hasValue(location)) {\r\n\t\t\tlocation = label.location;\r\n\t\t}\r\n\r\n\t\tposition = position + (endPosition - position) * location;\r\n\t\tlet radius = this.positionToPoint(position).y;\r\n\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\t\tif (axisRendererX) {\r\n\t\t\tlet axis = axisRendererX.axis;\r\n\t\t\tlet point = axisRendererX.positionToPoint(axis.start + (axis.end - axis.start) * this.axisLocation);\r\n\t\t\tlet angle = point.angle;\r\n\r\n\t\t\tpoint.x += radius * $math.cos(angle);\r\n\t\t\tpoint.y += radius * $math.sin(angle);\r\n\r\n\t\t\tthis.positionItem(label, point);\r\n\t\t\tthis.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions a tick element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param tick      Tick element\r\n\t * @param position  Position\r\n\t */\r\n\tpublic updateTickElement(tick: AxisTick, position: number): void {\r\n\t\tif (tick.element) {\r\n\t\t\tlet axisRendererX = this.axisRendererX;\r\n\t\t\tif (axisRendererX) {\r\n\t\t\t\tlet point = axisRendererX.positionToPoint(this.axisLocation);\r\n\t\t\t\tlet angle = point.angle;\r\n\r\n\t\t\t\tlet radius = this.positionToPoint(position).y;\r\n\r\n\t\t\t\tpoint.x += radius * $math.cos(angle);\r\n\t\t\t\tpoint.y += radius * $math.sin(angle);\r\n\r\n\t\t\t\tangle = $math.normalizeAngle(angle + 90);\r\n\t\t\t\tif (angle / 90 != Math.round(angle / 90)) {\r\n\t\t\t\t\ttick.pixelPerfect = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttick.pixelPerfect = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet tickLength = tick.length;\r\n\t\t\t\tif (tick.inside) {\r\n\t\t\t\t\ttickLength *= -1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttick.path = $path.moveTo({ x: 0, y: 0 }) + $path.lineTo({ x: tickLength * $math.cos(angle), y: tickLength * $math.sin(angle) });\r\n\t\t\t\tthis.positionItem(tick, point);\r\n\r\n\t\t\t\tthis.toggleVisibility(tick, position, 0, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions axis bullet.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param bullet       AxisBullet element\r\n\t * @param position     Starting position\r\n\t * @param endPosition  End position\r\n\t */\r\n\tpublic updateBullet(bullet: Sprite, position: number, endPosition: number): void {\r\n\t\tlet location = 0.5;\r\n\t\tif (bullet instanceof AxisBullet) {\r\n\t\t\tlocation = bullet.location;\r\n\t\t}\r\n\r\n\t\tposition = position + (endPosition - position) * location;\r\n\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\t\tif (axisRendererX) {\r\n\t\t\tlet point = axisRendererX.positionToPoint(this.axisLocation);\r\n\t\t\tlet angle = point.angle;\r\n\r\n\t\t\tlet radius = this.positionToPoint(position).y;\r\n\r\n\t\t\tpoint.x += radius * $math.cos(angle);\r\n\t\t\tpoint.y += radius * $math.sin(angle);\r\n\r\n\t\t\tangle = $math.normalizeAngle(angle + 90);\r\n\r\n\t\t\tthis.positionItem(bullet, point);\r\n\r\n\t\t\tthis.toggleVisibility(bullet, position, 0, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions the base grid element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateBaseGridElement(): void {\r\n\t\t// @todo? zero grid for curve chart, is it needed?\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if point is within bounds of a container.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param point Point coordinates\r\n\t * @return Fits?\r\n\t */\r\n\tpublic fitsToBounds(point: IPoint): boolean {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * [getPositionRangePath description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param startPosition  Starting position\r\n\t * @param endPosition    End position\r\n\t * @return SVG path\r\n\t */\r\n\tpublic getPositionRangePath(startPosition: number, endPosition: number): string {\r\n\r\n\t\tlet path = \"\";\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\r\n\t\tif (axisRendererX) {\r\n\t\t\tlet startX = axisRendererX.axis.start;\r\n\t\t\tlet endX = axisRendererX.axis.end;\r\n\r\n\t\t\tlet startY = this.axis.start;\r\n\t\t\tlet endY = this.axis.end;\r\n\r\n\t\t\tif ((startPosition <= startY && endPosition <= startY) || (startPosition >= endY && endPosition >= endY)) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\r\n\t\t\tstartPosition = $math.fitToRange(startPosition, startY, endY);\r\n\t\t\tendPosition = $math.fitToRange(endPosition, startY, endY);\r\n\r\n\t\t\tlet startRadius = $math.round(this.positionToPoint(startPosition).y, 1);\r\n\t\t\tlet endRadius = $math.round(this.positionToPoint(endPosition).y, 1);\r\n\r\n\t\t\tif ($type.isNaN(startRadius) || $type.isNaN(endRadius)) {\r\n\t\t\t\treturn \"\";\r\n\t\t\t}\r\n\r\n\t\t\tlet point = axisRendererX.positionToPoint(startX);\r\n\t\t\tlet angle = point.angle;\r\n\r\n\t\t\tpath = $path.moveTo(point);\r\n\r\n\t\t\tlet count = Math.ceil(axisRendererX.axisLength / axisRendererX.precisionStep);\r\n\t\t\tfor (let i = 0; i <= count; i++) {\r\n\r\n\t\t\t\tlet pos = startX + i / count * (endX - startX);\r\n\r\n\t\t\t\tpoint = axisRendererX.positionToPoint(pos);\r\n\t\t\t\tangle = point.angle;\r\n\r\n\t\t\t\tlet x = point.x + startRadius * $math.cos(angle);\r\n\t\t\t\tlet y = point.y + startRadius * $math.sin(angle);\r\n\r\n\t\t\t\tpath += $path.lineTo({ x: x, y: y });\r\n\t\t\t}\r\n\t\t\tfor (let i = count; i >= 0; i--) {\r\n\r\n\t\t\t\tlet pos = startX + i / count * (endX - startX);\r\n\r\n\t\t\t\tpoint = axisRendererX.positionToPoint(pos);\r\n\t\t\t\tangle = point.angle;\r\n\r\n\t\t\t\tlet x = point.x + endRadius * $math.cos(angle);\r\n\t\t\t\tlet y = point.y + endRadius * $math.sin(angle);\r\n\r\n\t\t\t\tpath += $path.lineTo({ x: x, y: y });\r\n\t\t\t}\r\n\r\n\t\t\tpath += $path.closePath();\r\n\r\n\t\t}\r\n\r\n\t\treturn path;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions an axis break element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param axisBreak Break element\r\n\t */\r\n\tpublic updateBreakElement(axisBreak: AxisBreak): void {\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\r\n\t\tif (axisRendererX) {\r\n\r\n\t\t\taxisBreak.fillShape.path = this.getPositionRangePath(axisBreak.startPosition, axisBreak.endPosition);\r\n\r\n\t\t\tthis.toggleVisibility(axisBreak.startLine, axisBreak.startPosition, 0, 1);\r\n\t\t\tthis.toggleVisibility(axisBreak.endLine, axisBreak.endPosition, 0, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Creates visual elements for and axis break.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param axisBreak Axis break\r\n\t */\r\n\tpublic createBreakSprites(axisBreak: AxisBreak): void {\r\n\t\taxisBreak.startLine = new WavedCircle();\r\n\t\taxisBreak.endLine = new WavedCircle();\r\n\t\taxisBreak.fillShape = new WavedCircle();\r\n\t}\r\n\r\n\t/**\r\n\t * Updates some of the Axis tooltip's visual properties, related to\r\n\t * rendering of the Axis.\r\n\t *\r\n\t * @todo Description (review)\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateTooltip(): void {\r\n\t\tlet axis: Axis = this.axis;\r\n\t\tif (axis) {\r\n\t\t\t/*\r\n\t\t\tlet bigNum: number = 4000;\r\n\t\t\tlet bbx: number = -4000;\r\n\t\t\tlet bby: number = -4000;\r\n\t\t\tlet bbw: number = bigNum * 2;\r\n\t\t\tlet bbh: number = bigNum * 2;\r\n\r\n\t\t\tthis.axis.updateTooltip(tooltipOrientation, { x: bbx, y: bby, width: bbw, height: bbh }); */\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a position on the axis to a coordinate in pixels.\r\n\t *\r\n\t * @param  position  Position (0-1)\r\n\t * @return           Coordinate (px)\r\n\t */\r\n\tpublic positionToCoordinate(position: number): number {\r\n\t\tlet coordinate: number;\r\n\t\tlet axis: Axis = this.axis;\r\n\t\tlet axisFullLength = axis.axisFullLength;\r\n\r\n\t\tif (axis.renderer.inversed) {\r\n\t\t\tcoordinate = (axis.end - position) * axisFullLength;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcoordinate = (position - axis.start) * axisFullLength;\r\n\t\t}\r\n\r\n\t\treturn $math.round(-this.innerRadius - coordinate, 4);\r\n\t}\r\n\r\n\r\n\t// TODO: make this universal?\r\n\r\n\t/**\r\n\t * Relative location of the Y axis along the length of the X axis.\r\n\t *\r\n\t * Values range from 0 (default) which means start of the X axis, to 1 meaning\r\n\t * end of the X axis.\r\n\t *\r\n\t * @default 0\r\n\t * @param  value  Axis location\r\n\t */\r\n\tpublic set axisLocation(value: number) {\r\n\t\tthis.setPropertyValue(\"axisLocation\", value);\r\n\t\tthis.invalidateAxisItems();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Axis location\r\n\t */\r\n\tpublic get axisLocation(): number {\r\n\t\treturn this.getPropertyValue(\"axisLocation\");\r\n\t}\r\n\r\n\t/**\r\n\t * Called when rendered is attached to an Axis, as well as a property of\r\n\t * Axis that might affect the appearance is updated.\r\n\t *\r\n\t * E.g. `axis.opposite`, `axis.inside`, etc.\r\n\t *\r\n\t * This method is called **before** draw, so that any related setting\r\n\t * changed in this method can be changed.\r\n\t *\r\n\t * @todo Description (review)\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic processRenderer(): void {\r\n\t\tsuper.processRenderer();\r\n\r\n\t\t// can not do this in init, as axis is set later\r\n\t\tlet axis = this.axis;\r\n\r\n\t\tif (axis) {\r\n\t\t\tlet title = axis.title;\r\n\t\t\tif (title) {\r\n\t\t\t\ttitle.isMeasured = false;\r\n\t\t\t\ttitle.horizontalCenter = \"middle\";\r\n\t\t\t\ttitle.verticalCenter = \"bottom\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a coordinate in pixels to a relative position. (0-1)\r\n\t *\r\n\t * @param coordinate  Coordinate (px)\r\n\t * @param coordinate2  Coordinate (px) Some more complicated axes need two coordinates\r\n\t * @return Position (0-1)\r\n\t */\r\n\tpublic coordinateToPosition(coordinate: number, coordinate2?: number): number {\r\n\t\tlet axisRendererX = this.axisRendererX;\r\n\t\tlet distance = coordinate;\r\n\t\tif (axisRendererX) {\r\n\t\t\tlet closestPoint = axisRendererX.polyspline.allPoints[axisRendererX.polyspline.getClosestPointIndex({ x: coordinate2, y: coordinate })];\r\n\t\t\tlet angle = closestPoint.angle - 90;\r\n\r\n\t\t\tdistance = $math.getDistance({ x: closestPoint.x + this.innerRadius * $math.cos(angle), y: closestPoint.y + this.innerRadius * $math.sin(angle) }, { x: coordinate2, y: coordinate });\r\n\t\t}\r\n\r\n\t\treturn super.coordinateToPosition(distance);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic toAxisPosition(value: number): number {\r\n\t\treturn value;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisRendererCurveY\"] = AxisRendererCurveY;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}