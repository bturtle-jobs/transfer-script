{"ast":null,"code":"\"use strict\";\n\nvar OldSelector = /*#__PURE__*/function () {\n  function OldSelector(selector, prefix) {\n    this.prefix = prefix;\n    this.prefixed = selector.prefixed(this.prefix);\n    this.regexp = selector.regexp(this.prefix);\n    this.prefixeds = selector.possible().map(function (x) {\n      return [selector.prefixed(x), selector.regexp(x)];\n    });\n    this.unprefixed = selector.name;\n    this.nameRegexp = selector.regexp();\n  }\n  /**\n     * Is rule a hack without unprefixed version bottom\n     */\n\n\n  var _proto = OldSelector.prototype;\n\n  _proto.isHack = function isHack(rule) {\n    var index = rule.parent.index(rule) + 1;\n    var rules = rule.parent.nodes;\n\n    while (index < rules.length) {\n      var before = rules[index].selector;\n\n      if (!before) {\n        return true;\n      }\n\n      if (before.indexOf(this.unprefixed) !== -1 && before.match(this.nameRegexp)) {\n        return false;\n      }\n\n      var some = false;\n\n      for (var _iterator = this.prefixeds, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var _ref2 = _ref,\n            string = _ref2[0],\n            regexp = _ref2[1];\n\n        if (before.indexOf(string) !== -1 && before.match(regexp)) {\n          some = true;\n          break;\n        }\n      }\n\n      if (!some) {\n        return true;\n      }\n\n      index += 1;\n    }\n\n    return true;\n  }\n  /**\n     * Does rule contain an unnecessary prefixed selector\n     */\n  ;\n\n  _proto.check = function check(rule) {\n    if (rule.selector.indexOf(this.prefixed) === -1) {\n      return false;\n    }\n\n    if (!rule.selector.match(this.regexp)) {\n      return false;\n    }\n\n    if (this.isHack(rule)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return OldSelector;\n}();\n\nmodule.exports = OldSelector;","map":{"version":3,"sources":["C:/Projects/Trunks/OWP-GIT/owp-fe/node_modules/autoprefixer/lib/old-selector.js"],"names":["OldSelector","selector","prefix","prefixed","regexp","prefixeds","possible","map","x","unprefixed","name","nameRegexp","_proto","prototype","isHack","rule","index","parent","rules","nodes","length","before","indexOf","match","some","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","value","_ref2","string","check","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar OldSelector =\n/*#__PURE__*/\nfunction () {\n  function OldSelector(selector, prefix) {\n    this.prefix = prefix;\n    this.prefixed = selector.prefixed(this.prefix);\n    this.regexp = selector.regexp(this.prefix);\n    this.prefixeds = selector.possible().map(function (x) {\n      return [selector.prefixed(x), selector.regexp(x)];\n    });\n    this.unprefixed = selector.name;\n    this.nameRegexp = selector.regexp();\n  }\n  /**\n     * Is rule a hack without unprefixed version bottom\n     */\n\n\n  var _proto = OldSelector.prototype;\n\n  _proto.isHack = function isHack(rule) {\n    var index = rule.parent.index(rule) + 1;\n    var rules = rule.parent.nodes;\n\n    while (index < rules.length) {\n      var before = rules[index].selector;\n\n      if (!before) {\n        return true;\n      }\n\n      if (before.indexOf(this.unprefixed) !== -1 && before.match(this.nameRegexp)) {\n        return false;\n      }\n\n      var some = false;\n\n      for (var _iterator = this.prefixeds, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var _ref2 = _ref,\n            string = _ref2[0],\n            regexp = _ref2[1];\n\n        if (before.indexOf(string) !== -1 && before.match(regexp)) {\n          some = true;\n          break;\n        }\n      }\n\n      if (!some) {\n        return true;\n      }\n\n      index += 1;\n    }\n\n    return true;\n  }\n  /**\n     * Does rule contain an unnecessary prefixed selector\n     */\n  ;\n\n  _proto.check = function check(rule) {\n    if (rule.selector.indexOf(this.prefixed) === -1) {\n      return false;\n    }\n\n    if (!rule.selector.match(this.regexp)) {\n      return false;\n    }\n\n    if (this.isHack(rule)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  return OldSelector;\n}();\n\nmodule.exports = OldSelector;"]},"metadata":{},"sourceType":"script"}