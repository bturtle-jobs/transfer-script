{"ast":null,"code":"Prism.languages['markup-templating'] = {};\nObject.defineProperties(Prism.languages['markup-templating'], {\n  buildPlaceholders: {\n    // Tokenize all inline templating expressions matching placeholderPattern\n    // If the replaceFilter function is provided, it will be called with every match.\n    // If it returns false, the match will not be replaced.\n    value: function value(env, language, placeholderPattern, replaceFilter) {\n      if (env.language !== language) {\n        return;\n      }\n\n      env.tokenStack = [];\n      env.code = env.code.replace(placeholderPattern, function (match) {\n        if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n          return match;\n        }\n\n        var i = env.tokenStack.length; // Check for existing strings\n\n        while (env.code.indexOf('___' + language.toUpperCase() + i + '___') !== -1) {\n          ++i;\n        } // Create a sparse array\n\n\n        env.tokenStack[i] = match;\n        return '___' + language.toUpperCase() + i + '___';\n      }); // Switch the grammar to markup\n\n      env.grammar = Prism.languages.markup;\n    }\n  },\n  tokenizePlaceholders: {\n    // Replace placeholders with proper tokens after tokenizing\n    value: function value(env, language) {\n      if (env.language !== language || !env.tokenStack) {\n        return;\n      } // Switch the grammar back\n\n\n      env.grammar = Prism.languages[language];\n      var j = 0;\n      var keys = Object.keys(env.tokenStack);\n\n      var walkTokens = function walkTokens(tokens) {\n        if (j >= keys.length) {\n          return;\n        }\n\n        for (var i = 0; i < tokens.length; i++) {\n          var token = tokens[i];\n\n          if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n            var k = keys[j];\n            var t = env.tokenStack[k];\n            var s = typeof token === 'string' ? token : token.content;\n            var index = s.indexOf('___' + language.toUpperCase() + k + '___');\n\n            if (index > -1) {\n              ++j;\n              var before = s.substring(0, index);\n              var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar, language), 'language-' + language, t);\n              var after = s.substring(index + ('___' + language.toUpperCase() + k + '___').length);\n              var replacement;\n\n              if (before || after) {\n                replacement = [before, middle, after].filter(function (v) {\n                  return !!v;\n                });\n                walkTokens(replacement);\n              } else {\n                replacement = middle;\n              }\n\n              if (typeof token === 'string') {\n                Array.prototype.splice.apply(tokens, [i, 1].concat(replacement));\n              } else {\n                token.content = replacement;\n              }\n\n              if (j >= keys.length) {\n                break;\n              }\n            }\n          } else if (token.content && typeof token.content !== 'string') {\n            walkTokens(token.content);\n          }\n        }\n      };\n\n      walkTokens(env.tokens);\n    }\n  }\n});","map":{"version":3,"sources":["C:/Projects/Trunks/OWP-GIT/owp-fe/node_modules/prismjs/components/prism-markup-templating.js"],"names":["Prism","languages","Object","defineProperties","buildPlaceholders","value","env","language","placeholderPattern","replaceFilter","tokenStack","code","replace","match","i","length","indexOf","toUpperCase","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","index","before","substring","middle","Token","tokenize","after","replacement","filter","v","Array","prototype","splice","apply","concat"],"mappings":"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","sourcesContent":["Prism.languages['markup-templating'] = {};\n\nObject.defineProperties(Prism.languages['markup-templating'], {\n\tbuildPlaceholders: {\n\t\t// Tokenize all inline templating expressions matching placeholderPattern\n\t\t// If the replaceFilter function is provided, it will be called with every match.\n\t\t// If it returns false, the match will not be replaced.\n\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\tif (env.language !== language) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tenv.tokenStack = [];\n\n\t\t\tenv.code = env.code.replace(placeholderPattern, function(match) {\n\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tvar i = env.tokenStack.length;\n\t\t\t\t// Check for existing strings\n\t\t\t\twhile (env.code.indexOf('___' + language.toUpperCase() + i + '___') !== -1)\n\t\t\t\t\t++i;\n\n\t\t\t\t// Create a sparse array\n\t\t\t\tenv.tokenStack[i] = match;\n\n\t\t\t\treturn '___' + language.toUpperCase() + i + '___';\n\t\t\t});\n\n\t\t\t// Switch the grammar to markup\n\t\t\tenv.grammar = Prism.languages.markup;\n\t\t}\n\t},\n\ttokenizePlaceholders: {\n\t\t// Replace placeholders with proper tokens after tokenizing\n\t\tvalue: function (env, language) {\n\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Switch the grammar back\n\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\tvar j = 0;\n\t\t\tvar keys = Object.keys(env.tokenStack);\n\t\t\tvar walkTokens = function (tokens) {\n\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\n\t\t\t\t\t\tvar index = s.indexOf('___' + language.toUpperCase() + k + '___');\n\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t++j;\n\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar, language), 'language-' + language, t);\n\t\t\t\t\t\t\tvar after = s.substring(index + ('___' + language.toUpperCase() + k + '___').length);\n\t\t\t\t\t\t\tvar replacement;\n\t\t\t\t\t\t\tif (before || after) {\n\t\t\t\t\t\t\t\treplacement = [before, middle, after].filter(function (v) { return !!v; });\n\t\t\t\t\t\t\t\twalkTokens(replacement);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treplacement = middle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\tArray.prototype.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (token.content && typeof token.content !== 'string') {\n\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\twalkTokens(env.tokens);\n\t\t}\n\t}\n});"]},"metadata":{},"sourceType":"script"}