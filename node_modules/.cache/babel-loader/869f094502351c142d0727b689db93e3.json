{"ast":null,"code":"\"use strict\";\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _defaults(subClass, superClass);\n}\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Declaration = /*#__PURE__*/function (_Prefixer) {\n  _inheritsLoose(Declaration, _Prefixer);\n\n  function Declaration() {\n    return _Prefixer.apply(this, arguments) || this;\n  }\n\n  var _proto = Declaration.prototype;\n  /**\n     * Always true, because we already get prefixer by property name\n     */\n\n  _proto.check = function check()\n  /* decl */\n  {\n    return true;\n  }\n  /**\n     * Return prefixed version of property\n     */\n  ;\n\n  _proto.prefixed = function prefixed(prop, prefix) {\n    return prefix + prop;\n  }\n  /**\n     * Return unprefixed version of property\n     */\n  ;\n\n  _proto.normalize = function normalize(prop) {\n    return prop;\n  }\n  /**\n     * Check `value`, that it contain other prefixes, rather than `prefix`\n     */\n  ;\n\n  _proto.otherPrefixes = function otherPrefixes(value, prefix) {\n    for (var _iterator = Browsers.prefixes(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var other = _ref;\n\n      if (other === prefix) {\n        continue;\n      }\n\n      if (value.indexOf(other) !== -1) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n     * Set prefix to declaration\n     */\n  ;\n\n  _proto.set = function set(decl, prefix) {\n    decl.prop = this.prefixed(decl.prop, prefix);\n    return decl;\n  }\n  /**\n     * Should we use visual cascade for prefixes\n     */\n  ;\n\n  _proto.needCascade = function needCascade(decl) {\n    if (!decl._autoprefixerCascade) {\n      decl._autoprefixerCascade = this.all.options.cascade !== false && decl.raw('before').indexOf('\\n') !== -1;\n    }\n\n    return decl._autoprefixerCascade;\n  }\n  /**\n     * Return maximum length of possible prefixed property\n     */\n  ;\n\n  _proto.maxPrefixed = function maxPrefixed(prefixes, decl) {\n    if (decl._autoprefixerMax) {\n      return decl._autoprefixerMax;\n    }\n\n    var max = 0;\n\n    for (var _iterator2 = prefixes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var prefix = _ref2;\n      prefix = utils.removeNote(prefix);\n\n      if (prefix.length > max) {\n        max = prefix.length;\n      }\n    }\n\n    decl._autoprefixerMax = max;\n    return decl._autoprefixerMax;\n  }\n  /**\n     * Calculate indentation to create visual cascade\n     */\n  ;\n\n  _proto.calcBefore = function calcBefore(prefixes, decl, prefix) {\n    if (prefix === void 0) {\n      prefix = '';\n    }\n\n    var max = this.maxPrefixed(prefixes, decl);\n    var diff = max - utils.removeNote(prefix).length;\n    var before = decl.raw('before');\n\n    if (diff > 0) {\n      before += Array(diff).fill(' ').join('');\n    }\n\n    return before;\n  }\n  /**\n     * Remove visual cascade\n     */\n  ;\n\n  _proto.restoreBefore = function restoreBefore(decl) {\n    var lines = decl.raw('before').split('\\n');\n    var min = lines[lines.length - 1];\n    this.all.group(decl).up(function (prefixed) {\n      var array = prefixed.raw('before').split('\\n');\n      var last = array[array.length - 1];\n\n      if (last.length < min.length) {\n        min = last;\n      }\n    });\n    lines[lines.length - 1] = min;\n    decl.raws.before = lines.join('\\n');\n  }\n  /**\n     * Clone and insert new declaration\n     */\n  ;\n\n  _proto.insert = function insert(decl, prefix, prefixes) {\n    var cloned = this.set(this.clone(decl), prefix);\n    if (!cloned) return undefined;\n    var already = decl.parent.some(function (i) {\n      return i.prop === cloned.prop && i.value === cloned.value;\n    });\n\n    if (already) {\n      return undefined;\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);\n    }\n\n    return decl.parent.insertBefore(decl, cloned);\n  }\n  /**\n     * Did this declaration has this prefix above\n     */\n  ;\n\n  _proto.isAlready = function isAlready(decl, prefixed) {\n    var already = this.all.group(decl).up(function (i) {\n      return i.prop === prefixed;\n    });\n\n    if (!already) {\n      already = this.all.group(decl).down(function (i) {\n        return i.prop === prefixed;\n      });\n    }\n\n    return already;\n  }\n  /**\n     * Clone and add prefixes for declaration\n     */\n  ;\n\n  _proto.add = function add(decl, prefix, prefixes, result) {\n    var prefixed = this.prefixed(decl.prop, prefix);\n\n    if (this.isAlready(decl, prefixed) || this.otherPrefixes(decl.value, prefix)) {\n      return undefined;\n    }\n\n    return this.insert(decl, prefix, prefixes, result);\n  }\n  /**\n     * Add spaces for visual cascade\n     */\n  ;\n\n  _proto.process = function process(decl, result) {\n    if (!this.needCascade(decl)) {\n      _Prefixer.prototype.process.call(this, decl, result);\n\n      return;\n    }\n\n    var prefixes = _Prefixer.prototype.process.call(this, decl, result);\n\n    if (!prefixes || !prefixes.length) {\n      return;\n    }\n\n    this.restoreBefore(decl);\n    decl.raws.before = this.calcBefore(prefixes, decl);\n  }\n  /**\n     * Return list of prefixed properties to clean old prefixes\n     */\n  ;\n\n  _proto.old = function old(prop, prefix) {\n    return [this.prefixed(prop, prefix)];\n  };\n\n  return Declaration;\n}(Prefixer);\n\nmodule.exports = Declaration;","map":{"version":3,"sources":["C:/Projects/Trunks/OWP-GIT/owp-fe/node_modules/autoprefixer/lib/declaration.js"],"names":["_defaults","obj","defaults","keys","Object","getOwnPropertyNames","i","length","key","value","getOwnPropertyDescriptor","configurable","undefined","defineProperty","_inheritsLoose","subClass","superClass","prototype","create","constructor","Prefixer","require","Browsers","utils","Declaration","_Prefixer","apply","arguments","_proto","check","prefixed","prop","prefix","normalize","otherPrefixes","_iterator","prefixes","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","other","indexOf","set","decl","needCascade","_autoprefixerCascade","all","options","cascade","raw","maxPrefixed","_autoprefixerMax","max","_iterator2","_isArray2","_i2","_ref2","removeNote","calcBefore","diff","before","fill","join","restoreBefore","lines","split","min","group","up","array","last","raws","insert","cloned","clone","already","parent","some","insertBefore","isAlready","down","add","result","process","call","old","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _defaults(subClass, superClass); }\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Declaration =\n/*#__PURE__*/\nfunction (_Prefixer) {\n  _inheritsLoose(Declaration, _Prefixer);\n\n  function Declaration() {\n    return _Prefixer.apply(this, arguments) || this;\n  }\n\n  var _proto = Declaration.prototype;\n\n  /**\n     * Always true, because we already get prefixer by property name\n     */\n  _proto.check = function check()\n  /* decl */\n  {\n    return true;\n  }\n  /**\n     * Return prefixed version of property\n     */\n  ;\n\n  _proto.prefixed = function prefixed(prop, prefix) {\n    return prefix + prop;\n  }\n  /**\n     * Return unprefixed version of property\n     */\n  ;\n\n  _proto.normalize = function normalize(prop) {\n    return prop;\n  }\n  /**\n     * Check `value`, that it contain other prefixes, rather than `prefix`\n     */\n  ;\n\n  _proto.otherPrefixes = function otherPrefixes(value, prefix) {\n    for (var _iterator = Browsers.prefixes(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var other = _ref;\n\n      if (other === prefix) {\n        continue;\n      }\n\n      if (value.indexOf(other) !== -1) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n     * Set prefix to declaration\n     */\n  ;\n\n  _proto.set = function set(decl, prefix) {\n    decl.prop = this.prefixed(decl.prop, prefix);\n    return decl;\n  }\n  /**\n     * Should we use visual cascade for prefixes\n     */\n  ;\n\n  _proto.needCascade = function needCascade(decl) {\n    if (!decl._autoprefixerCascade) {\n      decl._autoprefixerCascade = this.all.options.cascade !== false && decl.raw('before').indexOf('\\n') !== -1;\n    }\n\n    return decl._autoprefixerCascade;\n  }\n  /**\n     * Return maximum length of possible prefixed property\n     */\n  ;\n\n  _proto.maxPrefixed = function maxPrefixed(prefixes, decl) {\n    if (decl._autoprefixerMax) {\n      return decl._autoprefixerMax;\n    }\n\n    var max = 0;\n\n    for (var _iterator2 = prefixes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var prefix = _ref2;\n      prefix = utils.removeNote(prefix);\n\n      if (prefix.length > max) {\n        max = prefix.length;\n      }\n    }\n\n    decl._autoprefixerMax = max;\n    return decl._autoprefixerMax;\n  }\n  /**\n     * Calculate indentation to create visual cascade\n     */\n  ;\n\n  _proto.calcBefore = function calcBefore(prefixes, decl, prefix) {\n    if (prefix === void 0) {\n      prefix = '';\n    }\n\n    var max = this.maxPrefixed(prefixes, decl);\n    var diff = max - utils.removeNote(prefix).length;\n    var before = decl.raw('before');\n\n    if (diff > 0) {\n      before += Array(diff).fill(' ').join('');\n    }\n\n    return before;\n  }\n  /**\n     * Remove visual cascade\n     */\n  ;\n\n  _proto.restoreBefore = function restoreBefore(decl) {\n    var lines = decl.raw('before').split('\\n');\n    var min = lines[lines.length - 1];\n    this.all.group(decl).up(function (prefixed) {\n      var array = prefixed.raw('before').split('\\n');\n      var last = array[array.length - 1];\n\n      if (last.length < min.length) {\n        min = last;\n      }\n    });\n    lines[lines.length - 1] = min;\n    decl.raws.before = lines.join('\\n');\n  }\n  /**\n     * Clone and insert new declaration\n     */\n  ;\n\n  _proto.insert = function insert(decl, prefix, prefixes) {\n    var cloned = this.set(this.clone(decl), prefix);\n    if (!cloned) return undefined;\n    var already = decl.parent.some(function (i) {\n      return i.prop === cloned.prop && i.value === cloned.value;\n    });\n\n    if (already) {\n      return undefined;\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);\n    }\n\n    return decl.parent.insertBefore(decl, cloned);\n  }\n  /**\n     * Did this declaration has this prefix above\n     */\n  ;\n\n  _proto.isAlready = function isAlready(decl, prefixed) {\n    var already = this.all.group(decl).up(function (i) {\n      return i.prop === prefixed;\n    });\n\n    if (!already) {\n      already = this.all.group(decl).down(function (i) {\n        return i.prop === prefixed;\n      });\n    }\n\n    return already;\n  }\n  /**\n     * Clone and add prefixes for declaration\n     */\n  ;\n\n  _proto.add = function add(decl, prefix, prefixes, result) {\n    var prefixed = this.prefixed(decl.prop, prefix);\n\n    if (this.isAlready(decl, prefixed) || this.otherPrefixes(decl.value, prefix)) {\n      return undefined;\n    }\n\n    return this.insert(decl, prefix, prefixes, result);\n  }\n  /**\n     * Add spaces for visual cascade\n     */\n  ;\n\n  _proto.process = function process(decl, result) {\n    if (!this.needCascade(decl)) {\n      _Prefixer.prototype.process.call(this, decl, result);\n\n      return;\n    }\n\n    var prefixes = _Prefixer.prototype.process.call(this, decl, result);\n\n    if (!prefixes || !prefixes.length) {\n      return;\n    }\n\n    this.restoreBefore(decl);\n    decl.raws.before = this.calcBefore(prefixes, decl);\n  }\n  /**\n     * Return list of prefixed properties to clean old prefixes\n     */\n  ;\n\n  _proto.old = function old(prop, prefix) {\n    return [this.prefixed(prop, prefix)];\n  };\n\n  return Declaration;\n}(Prefixer);\n\nmodule.exports = Declaration;"]},"metadata":{},"sourceType":"script"}