{"ast":null,"code":"/**\r\n * Module, defining Axis Renderer for curved axes.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\nimport { Sprite } from \"../../core/Sprite\";\nimport { registry } from \"../../core/Registry\";\nimport { Polyspline } from \"../../core/elements/Polyspline\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $array from \"../../core/utils/Array\";\nimport { AxisBullet } from \"../../charts/axes/AxisBullet\";\nimport { wavedLine } from \"../../core/rendering/Smoothing\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A renderer for \"horizontal\" curve axis.\r\n */\n\nvar AxisRendererCurveX =\n/** @class */\nfunction (_super) {\n  __extends(AxisRendererCurveX, _super);\n  /**\r\n   * Constructor.\r\n   */\n\n\n  function AxisRendererCurveX() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * @ignore\r\n     */\n\n\n    _this.pixelRadiusReal = 0;\n    /**\r\n     * @readonly\r\n     * @ignore\r\n     */\n\n    _this.autoScaleScale = 1; // axis.layout = \"none\"; // does not trigger redraw when size changes\n    // axis.layout = \"none\"; // does not trigger redraw when size changes\n\n    _this.layout = \"none\";\n    _this.autoScale = true;\n    _this.autoCenter = true;\n    _this.isMeasured = false;\n    _this.className = \"AxisRendererCurveX\";\n    _this.line.strokeOpacity = 1;\n    _this.precisionStep = 10;\n    _this.line.isMeasured = false;\n    _this.points = [{\n      x: -300,\n      y: 0\n    }, {\n      x: 300,\n      y: 0\n    }];\n    _this._tempSprite = _this.createChild(Sprite);\n    _this._tempSprite.visible = false;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(AxisRendererCurveX.prototype, \"axisLength\", {\n    /**\r\n     * Returns actual length of the Axis, in pixels.\r\n     *\r\n     * @return Length (px)\r\n     */\n    get: function get() {\n      return this.polyspline.distance;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates and positions the axis line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  AxisRendererCurveX.prototype.updateAxisLine = function () {\n    this.line.path = this.polyspline.path;\n  };\n\n  Object.defineProperty(AxisRendererCurveX.prototype, \"polyspline\", {\n    /**\r\n     * @return Polyspline\r\n     */\n    get: function get() {\n      var polyspline = this.getPropertyValue(\"polyspline\");\n\n      if (!polyspline) {\n        polyspline = this.createChild(Polyspline);\n        polyspline.tensionX = 1;\n        polyspline.tensionY = 1;\n        this.polyspline = polyspline;\n      }\n\n      return polyspline;\n    },\n\n    /**\r\n     * A [[Polyspline]] elment that represents axis shape / curve.\r\n     *\r\n     * @param  value  Polyspline\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"polyspline\", value, true);\n      value.parent = this;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCurveX.prototype, \"autoScale\", {\n    /**\r\n     * @return Auto-scale?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"autoScale\");\n    },\n\n    /**\r\n     * Should the chart be scaled automatically, to fit into container?\r\n     *\r\n     * @default true\r\n     * @param  value  Auto-scale?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"autoScale\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCurveX.prototype, \"autoCenter\", {\n    /**\r\n     * @return {boolean} Auto-center?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"autoCenter\");\n    },\n\n    /**\r\n     * Should chart be centered within chart area?\r\n     *\r\n     * @default true\r\n     * @param  value  Auto-center?\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"autoCenter\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCurveX.prototype, \"precisionStep\", {\n    /**\r\n     * @return Precision step\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"precisionStep\");\n    },\n\n    /**\r\n     * Precision setting to use when drawing chart objects. Basically, it's\r\n     * number of pixels that a control point should be added at.\r\n     *\r\n     * The smaller the number, the finer line. However, small number will impact\r\n     * the performace.\r\n     *\r\n     * Depending on actual chart configuration, you might need to find the best\r\n     * possible value to balance between detail and good performance.\r\n     *\r\n     * @default 10\r\n     * @param  value  Precision step\r\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"precisionStep\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererCurveX.prototype, \"points\", {\n    /**\r\n     * @return Control points\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"points\");\n    },\n\n    /**\r\n     * An array of control points that define axis curve.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/timeline/#Control_points} for more info\r\n     * @param  value  Control points\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"points\", value, true)) {\n        this._pointsChanged = true;\n        this.polyspline.segments = [value];\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n  * @ignore\r\n  */\n\n  AxisRendererCurveX.prototype.setAxis = function (axis) {\n    var _this = this;\n\n    _super.prototype.setAxis.call(this, axis);\n\n    if (axis && axis.chart) {\n      var chart = axis.chart;\n\n      this._disposers.push(chart.curveContainer.events.on(\"positionchanged\", function () {\n        _this.handleSizeChange();\n      }));\n\n      this._disposers.push(chart.events.on(\"maxsizechanged\", function () {\n        _this.handleSizeChange();\n      }));\n    }\n  };\n  /**\r\n   * A handler for when axis size changes.\r\n   */\n\n\n  AxisRendererCurveX.prototype.handleSizeChange = function () {\n    if (this._pointsChanged) {\n      var pp = this.axis.getPositionRangePath(0, 1);\n      this._tempSprite.path = pp;\n      this._pointsChanged = false;\n    }\n\n    if (this.points) {\n      var chart = this.axis.chart;\n      var curveContainer = chart.curveContainer;\n      var mw = chart.plotContainer.maxWidth - curveContainer.pixelPaddingLeft - curveContainer.pixelPaddingRight;\n      var mh = chart.plotContainer.maxHeight - curveContainer.pixelPaddingTop - curveContainer.pixelPaddingBottom;\n\n      var bbox = this._tempSprite.element.getBBox();\n\n      var centerPoint_1 = {\n        x: 0,\n        y: 0\n      };\n\n      if (this.autoCenter) {\n        centerPoint_1 = {\n          x: bbox.x + bbox.width / 2,\n          y: bbox.y + bbox.height / 2\n        };\n      }\n\n      var scale_1 = 1;\n\n      if (this.autoScale) {\n        scale_1 = $math.min(mw / bbox.width, mh / bbox.height);\n      }\n\n      var modifiedPoints_1 = [];\n      $array.each(this.points, function (point) {\n        modifiedPoints_1.push({\n          x: (point.x - centerPoint_1.x) * scale_1,\n          y: (point.y - centerPoint_1.y) * scale_1\n        });\n      });\n      this.polyspline.segments = [modifiedPoints_1];\n    }\n  };\n  /**\r\n   * Converts relative position on axis to point coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @param position2  Position (0-1) Position on the second axis\r\n   * @return Point\r\n   */\n\n\n  AxisRendererCurveX.prototype.positionToPoint = function (position, position2) {\n    var axis = this.axis;\n    position = (position - axis.start) / (axis.end - axis.start);\n    var point = this.polyspline.positionToPoint(position, true);\n    point.angle += 90;\n    var axisRendererY = this.axisRendererY;\n\n    if ($type.isNumber(position2) && axisRendererY) {\n      var radius = axisRendererY.positionToPoint(position2).y;\n      point.x += radius * $math.cos(point.angle);\n      point.y += radius * $math.sin(point.angle);\n    }\n\n    return point;\n  };\n  /**\r\n   * Converts relative position (0-1) on axis to angle in degrees (0-360).\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Angle (0-360)\r\n   */\n\n\n  AxisRendererCurveX.prototype.positionToAngle = function (position) {\n    var axis = this.axis;\n    position = $math.max(0, (position - axis.start) / (axis.end - axis.start));\n    return this.polyspline.positionToPoint(position, true).angle + 90;\n  };\n  /**\r\n   * Updates and positions a grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param grid         Grid element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererCurveX.prototype.updateGridElement = function (grid, position, endPosition) {\n    if (grid.element) {\n      position = position + (endPosition - position) * grid.location;\n      grid.zIndex = 0;\n      grid.path = this.getGridPath(position);\n      this.toggleVisibility(grid, position, 0, 1);\n    }\n  };\n  /**\r\n   * [getGridPath description]\r\n   *\r\n   * @ignore\r\n   * @todo description\r\n   * @param   position  Position\r\n   * @return            SVG path\r\n   */\n\n\n  AxisRendererCurveX.prototype.getGridPath = function (position) {\n    var point = this.positionToPoint(position);\n    var angle = point.angle;\n    var axisRendererY = this.axisRendererY;\n\n    if (axisRendererY) {\n      var radius = -axisRendererY.radius;\n      var innerRadius = -axisRendererY.innerRadius;\n      return $path.moveTo({\n        x: point.x + innerRadius * $math.cos(angle),\n        y: point.y + innerRadius * $math.sin(angle)\n      }) + $path.lineTo({\n        x: point.x + radius * $math.cos(angle),\n        y: point.y + radius * $math.sin(angle)\n      });\n    }\n\n    return \"\";\n  };\n  /**\r\n   * Updates and positions a tick element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param tick      Tick element\r\n   * @param position  Position\r\n   */\n\n\n  AxisRendererCurveX.prototype.updateTickElement = function (tick, position) {\n    if (tick.element) {\n      var point = this.positionToPoint(position);\n      var angle = point.angle;\n      var tickLength = tick.length;\n\n      if (tick.inside) {\n        tickLength *= -1;\n      }\n\n      tick.path = $path.moveTo({\n        x: point.x,\n        y: point.y\n      }) + $path.lineTo({\n        x: point.x + tickLength * $math.cos(angle),\n        y: point.y + tickLength * $math.sin(angle)\n      });\n      this.toggleVisibility(tick, position, 0, 1);\n    }\n  };\n  /**\r\n   * Updates and positions a label element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param label        Label element\r\n   * @param position     Starting position\r\n   * @param endPosition  Ending position\r\n   */\n\n\n  AxisRendererCurveX.prototype.updateLabelElement = function (label, position, endPosition, location) {\n    if (!$type.hasValue(location)) {\n      location = label.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    var point = this.positionToPoint(position);\n    label.x = point.x;\n    label.y = point.y;\n    label.zIndex = 2;\n    this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\n  };\n  /**\r\n   * [getPositionRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param startPosition  Starting position\r\n   * @param endPosition    End position\r\n   * @return SVG path\r\n   */\n\n\n  AxisRendererCurveX.prototype.getPositionRangePath = function (startPosition, endPosition) {\n    var path = \"\";\n    var axisRendererY = this.axisRendererY;\n\n    if (axisRendererY) {\n      if (startPosition > endPosition) {\n        var temp = startPosition;\n        startPosition = endPosition;\n        endPosition = temp;\n      }\n\n      var startY = axisRendererY.axis.start;\n      var endY = axisRendererY.axis.end;\n      var startX = this.axis.start;\n      var endX = this.axis.end;\n\n      if (startPosition <= startX && endPosition <= startX || startPosition >= endX && endPosition >= endX) {\n        return path;\n      }\n\n      startPosition = $math.fitToRange(startPosition, startX, endX);\n      endPosition = $math.fitToRange(endPosition, startX, endX);\n\n      if (endPosition == startX || startPosition == endX) {\n        return path;\n      }\n\n      if (endPosition == startPosition) {\n        return path;\n      }\n\n      var startRadius = $math.round(axisRendererY.positionToPoint(startY).y, 1) | 0;\n      var endRadius = $math.round(axisRendererY.positionToPoint(endY).y, 1) | 0;\n      var point = this.positionToPoint(startPosition);\n      var angle = point.angle;\n      path = $path.moveTo(point);\n      var count = Math.ceil(this.axisLength / this.precisionStep * (endPosition - startPosition) / (endX - startX));\n\n      for (var i = 0; i <= count; i++) {\n        var pos = startPosition + i / count * (endPosition - startPosition);\n        point = this.positionToPoint(pos);\n        angle = point.angle;\n        var x = point.x + startRadius * $math.cos(angle);\n        var y = point.y + startRadius * $math.sin(angle);\n        path += $path.lineTo({\n          x: x,\n          y: y\n        });\n      }\n\n      for (var i = count; i >= 0; i--) {\n        var pos = startPosition + i / count * (endPosition - startPosition);\n        point = this.positionToPoint(pos);\n        angle = point.angle;\n        var x = point.x + endRadius * $math.cos(angle);\n        var y = point.y + endRadius * $math.sin(angle);\n        path += $path.lineTo({\n          x: x,\n          y: y\n        });\n      }\n\n      path += $path.closePath();\n    }\n\n    return path;\n  };\n  /**\r\n   * Updates and positions the base grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCurveX.prototype.updateBaseGridElement = function () {};\n  /**\r\n   * Updates and positions axis bullet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param bullet       AxisBullet element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n\n\n  AxisRendererCurveX.prototype.updateBullet = function (bullet, position, endPosition) {\n    var location = 0.5;\n\n    if (bullet instanceof AxisBullet) {\n      location = bullet.location;\n    }\n\n    position = position + (endPosition - position) * location;\n    var point = this.positionToPoint(position); //let angle = point.angle;\n\n    bullet.moveTo({\n      x: point.x,\n      y: point.y\n    }); //bullet.rotation = angle - 90;\n\n    this.toggleVisibility(bullet, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions an axis break element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Break element\r\n   */\n\n\n  AxisRendererCurveX.prototype.updateBreakElement = function (axisBreak) {\n    var axisRendererY = this.axisRendererY;\n\n    if (axisRendererY) {\n      var startPosition = axisBreak.startPosition;\n      var endPosition = axisBreak.endPosition;\n      var startAngle = this.positionToAngle(startPosition);\n      var startPoint = this.positionToPoint(startPosition);\n      var endAngle = this.positionToAngle(endPosition);\n      var endPoint = this.positionToPoint(endPosition);\n      var startLine = axisBreak.startLine;\n      var endLine = axisBreak.endLine;\n      var fillShape = axisBreak.fillShape;\n      var radius = -axisRendererY.radius + axisBreak.pixelMarginTop;\n      var innerRadius = -axisRendererY.innerRadius - axisBreak.pixelMarginBottom;\n      var x1 = startPoint.x + innerRadius * $math.cos(startAngle);\n      var y1 = startPoint.y + innerRadius * $math.sin(startAngle);\n      var x2 = startPoint.x + radius * $math.cos(startAngle);\n      var y2 = startPoint.y + radius * $math.sin(startAngle);\n      var x3 = endPoint.x + innerRadius * $math.cos(endAngle);\n      var y3 = endPoint.y + innerRadius * $math.sin(endAngle);\n      var x4 = endPoint.x + radius * $math.cos(endAngle);\n      var y4 = endPoint.y + radius * $math.sin(endAngle);\n      var p1 = {\n        x: x1,\n        y: y1\n      };\n      var p2 = {\n        x: x2,\n        y: y2\n      };\n      var p3 = {\n        x: x3,\n        y: y3\n      };\n      var p4 = {\n        x: x4,\n        y: y4\n      };\n      startLine.path = $path.moveTo(p1) + wavedLine(p1, p2, startLine.waveLength, startLine.waveHeight, startLine.tension, true);\n      endLine.path = $path.moveTo(p4) + wavedLine(p4, p3, endLine.waveLength, endLine.waveHeight, endLine.tension, true);\n      var path = $path.moveTo(p1);\n      path += wavedLine(p1, p2, fillShape.waveLength, fillShape.waveHeight, fillShape.tension, true);\n      var startX = this.axis.start;\n      var endX = this.axis.end;\n      var count = Math.ceil(this.axisLength / this.precisionStep * (endPosition - startPosition) / (endX - startX));\n\n      for (var i = 0; i <= count; i++) {\n        var pos = startPosition + i / count * (endPosition - startPosition);\n        var point = this.positionToPoint(pos);\n        var angle = point.angle;\n        var x = point.x + radius * $math.cos(angle);\n        var y = point.y + radius * $math.sin(angle);\n        path += $path.lineTo({\n          x: x,\n          y: y\n        });\n      }\n\n      path += wavedLine(p4, p3, fillShape.waveLength, fillShape.waveHeight, fillShape.tension, true);\n\n      for (var i = count; i >= 0; i--) {\n        var pos = startPosition + i / count * (endPosition - startPosition);\n        var point = this.positionToPoint(pos);\n        var angle = point.angle;\n        var x = point.x + innerRadius * $math.cos(angle);\n        var y = point.y + innerRadius * $math.sin(angle);\n        path += $path.lineTo({\n          x: x,\n          y: y\n        });\n      }\n\n      fillShape.path = path;\n      this.toggleVisibility(axisBreak.startLine, axisBreak.startPosition, 0, 1);\n      this.toggleVisibility(axisBreak.endLine, axisBreak.endPosition, 0, 1);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  AxisRendererCurveX.prototype.toAxisPosition = function (value) {\n    return value;\n  };\n  /**\r\n   * Converts a coordinate in pixels to a relative position. (0-1)\r\n   *\r\n   * @param coordinate  Coordinate (px)\r\n   * @param coordinate2  Coordinate (px) Some more complicated axes need two coordinates\r\n   * @return Position (0-1)\r\n   */\n\n\n  AxisRendererCurveX.prototype.coordinateToPosition = function (coordinate, coordinate2) {\n    var points = this.polyspline.allPoints;\n    var closestPoint = this.polyspline.getClosestPointIndex({\n      x: coordinate,\n      y: coordinate2\n    });\n    return _super.prototype.coordinateToPosition.call(this, closestPoint / (points.length - 1) * this.axisLength);\n  };\n  /**\r\n   * Updates some of the Axis tooltip's visual properties, related to\r\n   * rendering of the Axis.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  AxisRendererCurveX.prototype.updateTooltip = function () {};\n\n  Object.defineProperty(AxisRendererCurveX.prototype, \"inversed\", {\n    /**\r\n     * @return Flip axis?\r\n     */\n    get: function get() {\n      return false;\n    },\n\n    /**\r\n     * [[CurveChart]] does not support inversed X axes. This setting will be\r\n     * ignored.\r\n     * @param  value  Flip axis?\r\n     */\n    set: function set(value) {},\n    enumerable: true,\n    configurable: true\n  });\n  return AxisRendererCurveX;\n}(AxisRendererX);\n\nexport { AxisRendererCurveX };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"AxisRendererCurveX\"] = AxisRendererCurveX;","map":{"version":3,"sources":["../../../../../src/.internal/plugins/timeline/AxisRendererCurveX.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Module, defining Axis Renderer for curved axes.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisRendererX, IAxisRendererXAdapters, IAxisRendererXEvents, IAxisRendererXProperties } from \"../../charts/axes/AxisRendererX\";\r\n//import { AxisFillCircular } from \"./AxisFillCircular\";\r\nimport { AxisRendererCurveY } from \"./AxisRendererCurveY\";\r\nimport { CurveChart } from \"./CurveChart\";\r\nimport { Axis } from \"../../charts/axes/Axis\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\nimport { GridCircular } from \"../../charts/axes/GridCircular\";\r\nimport { AxisLabelCircular } from \"../../charts/axes/AxisLabelCircular\";\r\nimport { AxisFillCircular } from \"../../charts/axes/AxisFillCircular\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Polyspline } from \"../../core/elements/Polyspline\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport { AxisTick } from \"../../charts/axes/AxisTick\";\r\nimport { AxisBullet } from \"../../charts/axes/AxisBullet\";\r\nimport { AxisBreak } from \"../../charts/axes/AxisBreak\";\r\nimport { wavedLine } from \"../../core/rendering/Smoothing\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[AxisRendererCurveX]].\r\n */\r\nexport interface IAxisRendererCurveXProperties extends IAxisRendererXProperties {\r\n\r\n\t/**\r\n\t * A line object representing curve of the axis.\r\n\t */\r\n\tpolyspline?: Polyspline;\r\n\r\n\t/**\r\n\t * Precision setting to use when drawing chart objects. Basically, it's\r\n\t * number of pixels that a control point should be added at.\r\n\t *\r\n\t * The smaller the number, the finer line. However, small number will impact\r\n\t * the performace.\r\n\t *\r\n\t * Depending on actual chart configuration, you might need to find the best\r\n\t * possible value to balance between detail and good performance.\r\n\t *\r\n\t * @default 10\r\n\t */\r\n\tprecisionStep?: number;\r\n\r\n\t/**\r\n\t * Should the chart be scaled automatically, to fit into container?\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tautoScale?: boolean;\r\n\r\n\t/**\r\n\t * Should chart be centered within chart area?\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tautoCenter?: boolean;\r\n\r\n\t/**\r\n\t * Array of control points to draw axis curve along.\r\n\t */\r\n\tpoints?: IPoint[];\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[AxisRendererCurveX]].\r\n */\r\nexport interface IAxisRendererCurveXEvents extends IAxisRendererXEvents { }\r\n\r\n/**\r\n * Defines adapters for [[AxisRenderer]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IAxisRendererCurveXAdapters extends IAxisRendererXAdapters, IAxisRendererCurveXProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A renderer for \"horizontal\" curve axis.\r\n */\r\nexport class AxisRendererCurveX extends AxisRendererX {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IAxisRendererCurveXProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IAxisRendererCurveXAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IAxisRendererCurveXEvents;\r\n\r\n\t/**\r\n\t * Defines type of the grid elements.\r\n\t */\r\n\tpublic _gridType: GridCircular;\r\n\r\n\t/**\r\n\t * Defines type for the fill elements.\r\n\t */\r\n\tpublic _fillType: AxisFillCircular;\r\n\r\n\t/**\r\n\t * Defines type for the label elements.\r\n\t */\r\n\tpublic _labelType: AxisLabelCircular;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic pixelRadiusReal: number = 0;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic axisRendererY: AxisRendererCurveY;\r\n\r\n\t/**\r\n\t * @readonly\r\n\t * @ignore\r\n\t */\r\n\tpublic autoScaleScale: number = 1;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _tempSprite: Sprite;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _pointsChanged: boolean;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\r\n\t\t// axis.layout = \"none\"; // does not trigger redraw when size changes\r\n\r\n\t\t// axis.layout = \"none\"; // does not trigger redraw when size changes\r\n\t\tthis.layout = \"none\";\r\n\r\n\t\tthis.autoScale = true;\r\n\r\n\t\tthis.autoCenter = true;\r\n\r\n\t\tthis.isMeasured = false;\r\n\r\n\t\tthis.className = \"AxisRendererCurveX\";\r\n\r\n\t\tthis.line.strokeOpacity = 1;\r\n\r\n\t\tthis.precisionStep = 10;\r\n\r\n\t\tthis.line.isMeasured = false;\r\n\r\n\t\tthis.points = [{ x: -300, y: 0 }, { x: 300, y: 0 }];\r\n\r\n\t\tthis._tempSprite = this.createChild(Sprite);\r\n\t\tthis._tempSprite.visible = false;\r\n\r\n\t\tthis.applyTheme();\r\n\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns actual length of the Axis, in pixels.\r\n\t *\r\n\t * @return Length (px)\r\n\t */\r\n\tpublic get axisLength(): number {\r\n\t\treturn this.polyspline.distance;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions the axis line element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateAxisLine() {\r\n\t\tthis.line.path = this.polyspline.path;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[Polyspline]] elment that represents axis shape / curve.\r\n\t * \r\n\t * @param  value  Polyspline\r\n\t */\r\n\tpublic set polyspline(value: Polyspline) {\r\n\t\tthis.setPropertyValue(\"polyspline\", value, true);\r\n\t\tvalue.parent = this;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polyspline\r\n\t */\r\n\tpublic get polyspline(): Polyspline {\r\n\t\tlet polyspline = this.getPropertyValue(\"polyspline\");\r\n\t\tif (!polyspline) {\r\n\t\t\tpolyspline = this.createChild(Polyspline);\r\n\t\t\tpolyspline.tensionX = 1;\r\n\t\t\tpolyspline.tensionY = 1;\r\n\r\n\t\t\tthis.polyspline = polyspline;\r\n\t\t}\r\n\t\treturn polyspline;\r\n\t}\r\n\r\n\t/**\r\n\t * Should the chart be scaled automatically, to fit into container?\r\n\t *\r\n\t * @default true\r\n\t * @param  value  Auto-scale?\r\n\t */\r\n\tpublic set autoScale(value: boolean) {\r\n\t\tthis.setPropertyValue(\"autoScale\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Auto-scale?\r\n\t */\r\n\tpublic get autoScale(): boolean {\r\n\t\treturn this.getPropertyValue(\"autoScale\");\r\n\t}\r\n\r\n\t/**\r\n\t * Should chart be centered within chart area?\r\n\t *\r\n\t * @default true\r\n\t * @param  value  Auto-center?\r\n\t */\r\n\tpublic set autoCenter(value: boolean) {\r\n\t\tthis.setPropertyValue(\"autoCenter\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return {boolean} Auto-center?\r\n\t */\r\n\tpublic get autoCenter(): boolean {\r\n\t\treturn this.getPropertyValue(\"autoCenter\");\r\n\t}\r\n\r\n\t/**\r\n\t * Precision setting to use when drawing chart objects. Basically, it's\r\n\t * number of pixels that a control point should be added at.\r\n\t *\r\n\t * The smaller the number, the finer line. However, small number will impact\r\n\t * the performace.\r\n\t *\r\n\t * Depending on actual chart configuration, you might need to find the best\r\n\t * possible value to balance between detail and good performance.\r\n\t *\r\n\t * @default 10\r\n\t * @param  value  Precision step\r\n\t */\r\n\tpublic set precisionStep(value: number) {\r\n\t\tthis.setPropertyValue(\"precisionStep\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Precision step\r\n\t */\r\n\tpublic get precisionStep(): number {\r\n\t\treturn this.getPropertyValue(\"precisionStep\");\r\n\t}\r\n\r\n\t/**\r\n\t * An array of control points that define axis curve.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/timeline/#Control_points} for more info\r\n\t * @param  value  Control points\r\n\t */\r\n\tpublic set points(value: IPoint[]) {\r\n\t\tif (this.setPropertyValue(\"points\", value, true)) {\r\n\t\t\tthis._pointsChanged = true;\r\n\t\t\tthis.polyspline.segments = [value];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Control points\r\n\t */\r\n\tpublic get points(): IPoint[] {\r\n\t\treturn this.getPropertyValue(\"points\");\r\n\t}\r\n\r\n\t/**\r\n\t* @ignore\r\n\t*/\r\n\tpublic setAxis(axis: Axis): void {\r\n\t\tsuper.setAxis(axis);\r\n\t\tif (axis && axis.chart) {\r\n\t\t\tlet chart = <CurveChart>axis.chart;\r\n\t\t\tthis._disposers.push(chart.curveContainer.events.on(\"positionchanged\", () => {\r\n\t\t\t\tthis.handleSizeChange();\r\n\t\t\t}))\r\n\r\n\t\t\tthis._disposers.push(chart.events.on(\"maxsizechanged\", () => {\r\n\t\t\t\tthis.handleSizeChange();\r\n\t\t\t}))\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A handler for when axis size changes.\r\n\t */\r\n\tprotected handleSizeChange(): void {\r\n\r\n\t\tif (this._pointsChanged) {\r\n\t\t\tlet pp = this.axis.getPositionRangePath(0, 1);\r\n\t\t\tthis._tempSprite.path = pp;\r\n\t\t\tthis._pointsChanged = false;\r\n\t\t}\r\n\r\n\t\tif (this.points) {\r\n\t\t\tlet chart = <CurveChart>this.axis.chart;\r\n\t\t\tlet curveContainer = chart.curveContainer;\r\n\r\n\t\t\tlet mw = chart.plotContainer.maxWidth - curveContainer.pixelPaddingLeft - curveContainer.pixelPaddingRight;\r\n\t\t\tlet mh = chart.plotContainer.maxHeight - curveContainer.pixelPaddingTop - curveContainer.pixelPaddingBottom;\r\n\r\n\t\t\tlet bbox = this._tempSprite.element.getBBox();\r\n\t\t\tlet centerPoint = { x: 0, y: 0 };\r\n\r\n\t\t\tif (this.autoCenter) {\r\n\t\t\t\tcenterPoint = { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 };\r\n\t\t\t}\r\n\r\n\t\t\tlet scale = 1;\r\n\t\t\tif (this.autoScale) {\r\n\t\t\t\tscale = $math.min(mw / bbox.width, mh / bbox.height);\r\n\t\t\t}\r\n\r\n\t\t\tlet modifiedPoints: IPoint[] = [];\r\n\t\t\t$array.each(this.points, (point) => {\r\n\t\t\t\tmodifiedPoints.push({ x: (point.x - centerPoint.x) * scale, y: (point.y - centerPoint.y) * scale });\r\n\t\t\t})\r\n\r\n\t\t\tthis.polyspline.segments = [modifiedPoints];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts relative position on axis to point coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @param position2  Position (0-1) Position on the second axis\r\n\t * @return Point\r\n\t */\r\n\tpublic positionToPoint(position: number, position2?: number): IOrientationPoint {\r\n\r\n\t\tlet axis = this.axis;\r\n\r\n\t\tposition = (position - axis.start) / (axis.end - axis.start);\r\n\r\n\t\tlet point = this.polyspline.positionToPoint(position, true);\r\n\t\tpoint.angle += 90;\r\n\r\n\t\tlet axisRendererY = this.axisRendererY;\r\n\r\n\t\tif ($type.isNumber(position2) && axisRendererY) {\r\n\t\t\tlet radius = axisRendererY.positionToPoint(position2).y;\r\n\r\n\t\t\tpoint.x += radius * $math.cos(point.angle);\r\n\t\t\tpoint.y += radius * $math.sin(point.angle);\r\n\t\t}\r\n\r\n\t\treturn point;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts relative position (0-1) on axis to angle in degrees (0-360).\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Angle (0-360)\r\n\t */\r\n\tpublic positionToAngle(position: number): number {\r\n\r\n\t\tlet axis = this.axis;\r\n\t\tposition = $math.max(0, (position - axis.start) / (axis.end - axis.start));\r\n\r\n\t\treturn this.polyspline.positionToPoint(position, true).angle + 90;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions a grid element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param grid         Grid element\r\n\t * @param position     Starting position\r\n\t * @param endPosition  End position\r\n\t */\r\n\tpublic updateGridElement(grid: GridCircular, position: number, endPosition: number) {\r\n\t\tif (grid.element) {\r\n\t\t\tposition = position + (endPosition - position) * grid.location;\r\n\r\n\t\t\tgrid.zIndex = 0;\r\n\r\n\t\t\tgrid.path = this.getGridPath(position);\r\n\r\n\t\t\tthis.toggleVisibility(grid, position, 0, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [getGridPath description]\r\n\t *\r\n\t * @ignore\r\n\t * @todo description\r\n\t * @param   position  Position\r\n\t * @return            SVG path\r\n\t */\r\n\tpublic getGridPath(position: number): string {\r\n\r\n\t\tlet point = this.positionToPoint(position);\r\n\r\n\t\tlet angle: number = point.angle;\r\n\t\tlet axisRendererY = this.axisRendererY;\r\n\t\tif (axisRendererY) {\r\n\t\t\tlet radius: number = -axisRendererY.radius;\r\n\t\t\tlet innerRadius: number = -axisRendererY.innerRadius;\r\n\r\n\t\t\treturn $path.moveTo({ x: point.x + innerRadius * $math.cos(angle), y: point.y + innerRadius * $math.sin(angle) }) + $path.lineTo({ x: point.x + radius * $math.cos(angle), y: point.y + radius * $math.sin(angle) });\r\n\t\t}\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions a tick element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param tick      Tick element\r\n\t * @param position  Position\r\n\t */\r\n\tpublic updateTickElement(tick: AxisTick, position: number): void {\r\n\t\tif (tick.element) {\r\n\r\n\t\t\tlet point = this.positionToPoint(position);\r\n\t\t\tlet angle = point.angle;\r\n\r\n\t\t\tlet tickLength = tick.length;\r\n\t\t\tif (tick.inside) {\r\n\t\t\t\ttickLength *= -1;\r\n\t\t\t}\r\n\r\n\t\t\ttick.path = $path.moveTo({ x: point.x, y: point.y }) + $path.lineTo({ x: point.x + tickLength * $math.cos(angle), y: point.y + tickLength * $math.sin(angle) });\r\n\t\t\tthis.toggleVisibility(tick, position, 0, 1);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions a label element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param label        Label element\r\n\t * @param position     Starting position\r\n\t * @param endPosition  Ending position\r\n\t */\r\n\tpublic updateLabelElement(label: this[\"_labelType\"], position: number, endPosition: number, location?: number) {\r\n\r\n\t\tif (!$type.hasValue(location)) {\r\n\t\t\tlocation = label.location;\r\n\t\t}\r\n\r\n\t\tposition = position + (endPosition - position) * location;\r\n\r\n\t\tlet point: IPoint = this.positionToPoint(position);\r\n\r\n\t\tlabel.x = point.x;\r\n\t\tlabel.y = point.y;\r\n\t\tlabel.zIndex = 2;\r\n\r\n\t\tthis.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\r\n\t}\r\n\r\n\t/**\r\n\t * [getPositionRangePath description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param startPosition  Starting position\r\n\t * @param endPosition    End position\r\n\t * @return SVG path\r\n\t */\r\n\tpublic getPositionRangePath(startPosition: number, endPosition: number): string {\r\n\t\tlet path = \"\";\r\n\r\n\t\tlet axisRendererY = this.axisRendererY;\r\n\t\tif (axisRendererY) {\r\n\r\n\t\t\tif (startPosition > endPosition) {\r\n\t\t\t\tlet temp = startPosition;\r\n\t\t\t\tstartPosition = endPosition;\r\n\t\t\t\tendPosition = temp;\r\n\t\t\t}\r\n\r\n\t\t\tlet startY = axisRendererY.axis.start;\r\n\t\t\tlet endY = axisRendererY.axis.end;\r\n\r\n\t\t\tlet startX = this.axis.start;\r\n\t\t\tlet endX = this.axis.end;\r\n\r\n\t\t\tif ((startPosition <= startX && endPosition <= startX) || (startPosition >= endX && endPosition >= endX)) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\r\n\t\t\tstartPosition = $math.fitToRange(startPosition, startX, endX);\r\n\t\t\tendPosition = $math.fitToRange(endPosition, startX, endX);\r\n\r\n\t\t\tif (endPosition == startX || startPosition == endX) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\r\n\t\t\tif (endPosition == startPosition) {\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\r\n\t\t\tlet startRadius = $math.round(axisRendererY.positionToPoint(startY).y, 1) | 0;\r\n\t\t\tlet endRadius = $math.round(axisRendererY.positionToPoint(endY).y, 1) | 0;\r\n\r\n\t\t\tlet point = this.positionToPoint(startPosition);\r\n\t\t\tlet angle = point.angle;\r\n\r\n\t\t\tpath = $path.moveTo(point);\r\n\r\n\t\t\tlet count = Math.ceil(this.axisLength / this.precisionStep * (endPosition - startPosition) / (endX - startX));\r\n\r\n\t\t\tfor (let i = 0; i <= count; i++) {\r\n\r\n\t\t\t\tlet pos = startPosition + i / count * (endPosition - startPosition);\r\n\r\n\t\t\t\tpoint = this.positionToPoint(pos);\r\n\r\n\t\t\t\tangle = point.angle;\r\n\r\n\t\t\t\tlet x = point.x + startRadius * $math.cos(angle);\r\n\t\t\t\tlet y = point.y + startRadius * $math.sin(angle);\r\n\r\n\t\t\t\tpath += $path.lineTo({ x: x, y: y });\r\n\t\t\t}\r\n\t\t\tfor (let i = count; i >= 0; i--) {\r\n\r\n\t\t\t\tlet pos = startPosition + i / count * (endPosition - startPosition);\r\n\r\n\t\t\t\tpoint = this.positionToPoint(pos);\r\n\t\t\t\tangle = point.angle;\r\n\r\n\t\t\t\tlet x = point.x + endRadius * $math.cos(angle);\r\n\t\t\t\tlet y = point.y + endRadius * $math.sin(angle);\r\n\r\n\t\t\t\tpath += $path.lineTo({ x: x, y: y });\r\n\t\t\t}\r\n\r\n\t\t\tpath += $path.closePath();\r\n\t\t}\r\n\t\treturn path;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions the base grid element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateBaseGridElement(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions axis bullet.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param bullet       AxisBullet element\r\n\t * @param position     Starting position\r\n\t * @param endPosition  End position\r\n\t */\r\n\tpublic updateBullet(bullet: Sprite, position: number, endPosition: number): void {\r\n\t\tlet location = 0.5;\r\n\t\tif (bullet instanceof AxisBullet) {\r\n\t\t\tlocation = bullet.location;\r\n\t\t}\r\n\r\n\t\tposition = position + (endPosition - position) * location;\r\n\r\n\t\tlet point = this.positionToPoint(position);\r\n\t\t//let angle = point.angle;\r\n\r\n\t\tbullet.moveTo({ x: point.x, y: point.y });\r\n\t\t//bullet.rotation = angle - 90;\r\n\r\n\t\tthis.toggleVisibility(bullet, position, 0, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Updates and positions an axis break element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param axisBreak Break element\r\n\t */\r\n\tpublic updateBreakElement(axisBreak: AxisBreak): void {\r\n\t\tlet axisRendererY = this.axisRendererY;\r\n\r\n\t\tif (axisRendererY) {\r\n\r\n\t\t\tlet startPosition = axisBreak.startPosition;\r\n\t\t\tlet endPosition = axisBreak.endPosition;\r\n\r\n\t\t\tlet startAngle = this.positionToAngle(startPosition);\r\n\t\t\tlet startPoint = this.positionToPoint(startPosition);\r\n\r\n\t\t\tlet endAngle = this.positionToAngle(endPosition);\r\n\t\t\tlet endPoint = this.positionToPoint(endPosition);\r\n\r\n\t\t\tlet startLine = axisBreak.startLine;\r\n\t\t\tlet endLine = axisBreak.endLine;\r\n\t\t\tlet fillShape = axisBreak.fillShape;\r\n\r\n\t\t\tlet radius: number = -axisRendererY.radius + axisBreak.pixelMarginTop;\r\n\t\t\tlet innerRadius: number = -axisRendererY.innerRadius - axisBreak.pixelMarginBottom;\r\n\r\n\t\t\tlet x1 = startPoint.x + innerRadius * $math.cos(startAngle);\r\n\t\t\tlet y1 = startPoint.y + innerRadius * $math.sin(startAngle);\r\n\r\n\t\t\tlet x2 = startPoint.x + radius * $math.cos(startAngle);\r\n\t\t\tlet y2 = startPoint.y + radius * $math.sin(startAngle);\r\n\r\n\t\t\tlet x3 = endPoint.x + innerRadius * $math.cos(endAngle);\r\n\t\t\tlet y3 = endPoint.y + innerRadius * $math.sin(endAngle);\r\n\r\n\t\t\tlet x4 = endPoint.x + radius * $math.cos(endAngle);\r\n\t\t\tlet y4 = endPoint.y + radius * $math.sin(endAngle);\r\n\r\n\t\t\tlet p1 = { x: x1, y: y1 };\r\n\t\t\tlet p2 = { x: x2, y: y2 };\r\n\r\n\t\t\tlet p3 = { x: x3, y: y3 };\r\n\t\t\tlet p4 = { x: x4, y: y4 };\r\n\r\n\t\t\tstartLine.path = $path.moveTo(p1) + wavedLine(p1, p2, startLine.waveLength, startLine.waveHeight, startLine.tension, true);\r\n\t\t\tendLine.path = $path.moveTo(p4) + wavedLine(p4, p3, endLine.waveLength, endLine.waveHeight, endLine.tension, true);\r\n\r\n\t\t\tlet path = $path.moveTo(p1);\r\n\t\t\tpath += wavedLine(p1, p2, fillShape.waveLength, fillShape.waveHeight, fillShape.tension, true);\r\n\r\n\t\t\tlet startX = this.axis.start;\r\n\t\t\tlet endX = this.axis.end;\r\n\r\n\t\t\tlet count = Math.ceil(this.axisLength / this.precisionStep * (endPosition - startPosition) / (endX - startX));\r\n\r\n\t\t\tfor (let i = 0; i <= count; i++) {\r\n\r\n\t\t\t\tlet pos = startPosition + i / count * (endPosition - startPosition);\r\n\r\n\t\t\t\tlet point = this.positionToPoint(pos);\r\n\t\t\t\tlet angle = point.angle;\r\n\r\n\t\t\t\tlet x = point.x + radius * $math.cos(angle);\r\n\t\t\t\tlet y = point.y + radius * $math.sin(angle);\r\n\r\n\t\t\t\tpath += $path.lineTo({ x: x, y: y });\r\n\t\t\t}\r\n\r\n\t\t\tpath += wavedLine(p4, p3, fillShape.waveLength, fillShape.waveHeight, fillShape.tension, true);\r\n\r\n\t\t\tfor (let i = count; i >= 0; i--) {\r\n\r\n\t\t\t\tlet pos = startPosition + i / count * (endPosition - startPosition);\r\n\r\n\r\n\t\t\t\tlet point = this.positionToPoint(pos);\r\n\t\t\t\tlet angle = point.angle;\r\n\r\n\t\t\t\tlet x = point.x + innerRadius * $math.cos(angle);\r\n\t\t\t\tlet y = point.y + innerRadius * $math.sin(angle);\r\n\r\n\t\t\t\tpath += $path.lineTo({ x: x, y: y });\r\n\t\t\t}\r\n\r\n\t\t\tfillShape.path = path;\r\n\r\n\t\t\tthis.toggleVisibility(axisBreak.startLine, axisBreak.startPosition, 0, 1);\r\n\t\t\tthis.toggleVisibility(axisBreak.endLine, axisBreak.endPosition, 0, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic toAxisPosition(value: number): number {\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a coordinate in pixels to a relative position. (0-1)\r\n\t *\r\n\t * @param coordinate  Coordinate (px)\r\n\t * @param coordinate2  Coordinate (px) Some more complicated axes need two coordinates\r\n\t * @return Position (0-1)\r\n\t */\r\n\tpublic coordinateToPosition(coordinate: number, coordinate2?: number): number {\r\n\t\tlet points = this.polyspline.allPoints;\r\n\r\n\t\tlet closestPoint = this.polyspline.getClosestPointIndex({ x: coordinate, y: coordinate2 });\r\n\r\n\t\treturn super.coordinateToPosition(closestPoint / (points.length - 1) * this.axisLength);\r\n\t}\r\n\r\n\t/**\r\n\t * Updates some of the Axis tooltip's visual properties, related to\r\n\t * rendering of the Axis.\r\n\t *\r\n\t * @todo Description (review)\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateTooltip(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * [[CurveChart]] does not support inversed X axes. This setting will be\r\n\t * ignored.\r\n\t * @param  value  Flip axis?\r\n\t */\r\n\tpublic set inversed(value: boolean) {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @return Flip axis?\r\n\t */\r\n\tpublic get inversed(): boolean {\r\n\t\treturn false;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisRendererCurveX\"] = AxisRendererCurveX;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}