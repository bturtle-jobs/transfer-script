{"ast":null,"code":"\"use strict\";\n\nvar parser = require('postcss-value-parser');\n\nvar list = require('postcss').list;\n\nvar uniq = require('../utils').uniq;\n\nvar escapeRegexp = require('../utils').escapeRegexp;\n\nvar splitSelector = require('../utils').splitSelector;\n\nfunction convert(value) {\n  if (value && value.length === 2 && value[0] === 'span' && parseInt(value[1], 10) > 0) {\n    return [false, parseInt(value[1], 10)];\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false];\n  }\n\n  return [false, false];\n}\n\nfunction translate(values, startIndex, endIndex) {\n  var startValue = values[startIndex];\n  var endValue = values[endIndex];\n\n  if (!startValue) {\n    return [false, false];\n  }\n\n  var _convert = convert(startValue),\n      start = _convert[0],\n      spanStart = _convert[1];\n\n  var _convert2 = convert(endValue),\n      end = _convert2[0],\n      spanEnd = _convert2[1];\n\n  if (start && !endValue) {\n    return [start, false];\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart];\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd];\n  }\n\n  if (start && end) {\n    return [start, end - start];\n  }\n\n  return [false, false];\n}\n\nfunction parse(decl) {\n  var node = parser(decl.value);\n  var values = [];\n  var current = 0;\n  values[current] = [];\n\n  for (var _iterator = node.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var i = _ref;\n\n    if (i.type === 'div') {\n      current += 1;\n      values[current] = [];\n    } else if (i.type === 'word') {\n      values[current].push(i.value);\n    }\n  }\n\n  return values;\n}\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(function (i) {\n    return i.prop === \"-ms-\" + prop;\n  })) {\n    decl.cloneBefore({\n      prop: \"-ms-\" + prop,\n      value: value.toString()\n    });\n  }\n} // Track transforms\n\n\nfunction prefixTrackProp(_ref2) {\n  var prop = _ref2.prop,\n      prefix = _ref2.prefix;\n  return prefix + prop.replace('template-', '');\n}\n\nfunction transformRepeat(_ref3, _ref4) {\n  var nodes = _ref3.nodes;\n  var gap = _ref4.gap;\n\n  var _nodes$reduce = nodes.reduce(function (result, node) {\n    if (node.type === 'div' && node.value === ',') {\n      result.key = 'size';\n    } else {\n      result[result.key].push(parser.stringify(node));\n    }\n\n    return result;\n  }, {\n    key: 'count',\n    size: [],\n    count: []\n  }),\n      count = _nodes$reduce.count,\n      size = _nodes$reduce.size; // insert gap values\n\n\n  if (gap) {\n    var _ret = function () {\n      size = size.filter(function (i) {\n        return i.trim();\n      });\n      var val = [];\n\n      var _loop = function _loop(i) {\n        size.forEach(function (item, index) {\n          if (index > 0 || i > 1) {\n            val.push(gap);\n          }\n\n          val.push(item);\n        });\n      };\n\n      for (var i = 1; i <= count; i++) {\n        _loop(i);\n      }\n\n      return {\n        v: val.join(' ')\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return \"(\" + size.join('') + \")[\" + count.join('') + \"]\";\n}\n\nfunction prefixTrackValue(_ref5) {\n  var value = _ref5.value,\n      gap = _ref5.gap;\n  var result = parser(value).nodes.reduce(function (nodes, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, {\n          gap: gap\n        })\n      });\n    }\n\n    if (gap && node.type === 'space') {\n      return nodes.concat({\n        type: 'space',\n        value: ' '\n      }, {\n        type: 'word',\n        value: gap\n      }, node);\n    }\n\n    return nodes.concat(node);\n  }, []);\n  return parser.stringify(result);\n} // Parse grid-template-areas\n\n\nvar DOTS = /^\\.+$/;\n\nfunction track(start, end) {\n  return {\n    start: start,\n    end: end,\n    span: end - start\n  };\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g);\n}\n\nfunction parseGridAreas(_ref6) {\n  var rows = _ref6.rows,\n      gap = _ref6.gap;\n  return rows.reduce(function (areas, line, rowIndex) {\n    if (gap.row) rowIndex *= 2;\n    if (line.trim() === '') return areas;\n    getColumns(line).forEach(function (area, columnIndex) {\n      if (DOTS.test(area)) return;\n      if (gap.column) columnIndex *= 2;\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        };\n      } else {\n        var _areas$area = areas[area],\n            column = _areas$area.column,\n            row = _areas$area.row;\n        column.start = Math.min(column.start, columnIndex + 1);\n        column.end = Math.max(column.end, columnIndex + 2);\n        column.span = column.end - column.start;\n        row.start = Math.min(row.start, rowIndex + 1);\n        row.end = Math.max(row.end, rowIndex + 2);\n        row.span = row.end - row.start;\n      }\n    });\n    return areas;\n  }, {});\n} // Parse grid-template\n\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+\\]$/.test(node.value);\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto');\n  }\n\n  return result;\n}\n\nfunction parseTemplate(_ref7) {\n  var decl = _ref7.decl,\n      gap = _ref7.gap;\n  var gridTemplate = parser(decl.value).nodes.reduce(function (result, node) {\n    var type = node.type,\n        value = node.value;\n    if (testTrack(node) || type === 'space') return result; // area\n\n    if (type === 'string') {\n      result = verifyRowSize(result);\n      result.areas.push(value);\n    } // values and function\n\n\n    if (type === 'word' || type === 'function') {\n      result[result.key].push(parser.stringify(node));\n    } // divider(/)\n\n\n    if (type === 'div' && value === '/') {\n      result.key = 'columns';\n      result = verifyRowSize(result);\n    }\n\n    return result;\n  }, {\n    key: 'rows',\n    columns: [],\n    rows: [],\n    areas: []\n  });\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap: gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  };\n} // Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\n\n\nfunction getMSDecls(area, addRowSpan, addColumnSpan) {\n  if (addRowSpan === void 0) {\n    addRowSpan = false;\n  }\n\n  if (addColumnSpan === void 0) {\n    addColumnSpan = false;\n  }\n\n  return [].concat({\n    prop: '-ms-grid-row',\n    value: String(area.row.start)\n  }, area.row.span > 1 || addRowSpan ? {\n    prop: '-ms-grid-row-span',\n    value: String(area.row.span)\n  } : [], {\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  }, area.column.span > 1 || addColumnSpan ? {\n    prop: '-ms-grid-column-span',\n    value: String(area.column.span)\n  } : []);\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent;\n  }\n\n  if (!parent.parent) {\n    return false;\n  }\n\n  return getParentMedia(parent.parent);\n}\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\n\n\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(function (selector) {\n    var selectorBySpace = list.space(selector);\n    var selectorByComma = list.comma(selector);\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('');\n    }\n\n    return selector;\n  });\n  return ruleSelectors.map(function (ruleSelector) {\n    var newSelector = templateSelectors.map(function (tplSelector, index) {\n      var space = index === 0 ? '' : ' ';\n      return \"\" + space + tplSelector + \" > \" + ruleSelector;\n    });\n    return newSelector;\n  });\n}\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\n\n\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(function (sel) {\n    return ruleB.selectors.some(function (s) {\n      return s === sel;\n    });\n  });\n}\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\n\n\nfunction parseGridTemplatesData(css) {\n  var parsed = []; // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n\n  css.walkDecls(/grid-template(-areas)?$/, function (d) {\n    var rule = d.parent;\n    var media = getParentMedia(rule);\n    var gap = getGridGap(d);\n    var inheritedGap = inheritGridGap(d, gap);\n\n    var _parseTemplate = parseTemplate({\n      decl: d,\n      gap: inheritedGap || gap\n    }),\n        areas = _parseTemplate.areas;\n\n    var areaNames = Object.keys(areas); // skip node if it doesn't have areas\n\n    if (areaNames.length === 0) {\n      return true;\n    } // check parsed array for item that include the same area names\n    // return index of that item\n\n\n    var index = parsed.reduce(function (acc, _ref8, idx) {\n      var allAreas = _ref8.allAreas;\n      var hasAreas = allAreas && areaNames.some(function (area) {\n        return allAreas.includes(area);\n      });\n      return hasAreas ? idx : acc;\n    }, null);\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      var _parsed$index = parsed[index],\n          allAreas = _parsed$index.allAreas,\n          rules = _parsed$index.rules; // check if rule has no duplicate area names\n\n      var hasNoDuplicates = rules.some(function (r) {\n        return r.hasDuplicates === false && selectorsEqual(r, rule);\n      });\n      var duplicatesFound = false; // check need to gather all duplicate area names\n\n      var duplicateAreaNames = rules.reduce(function (acc, r) {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true;\n          return r.duplicateAreaNames;\n        }\n\n        if (!duplicatesFound) {\n          areaNames.forEach(function (name) {\n            if (r.areas[name]) {\n              acc.push(name);\n            }\n          });\n        }\n\n        return uniq(acc);\n      }, []); // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n\n      rules.forEach(function (r) {\n        areaNames.forEach(function (name) {\n          var area = r.areas[name];\n\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true;\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true;\n          }\n        });\n      });\n      parsed[index].allAreas = uniq([].concat(allAreas, areaNames));\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames: duplicateAreaNames,\n        areas: areas\n      });\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [{\n          hasDuplicates: false,\n          duplicateRules: [],\n          params: media.params,\n          selectors: rule.selectors,\n          node: rule,\n          duplicateAreaNames: [],\n          areas: areas\n        }]\n      });\n    }\n\n    return undefined;\n  });\n  return parsed;\n}\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\n\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  var gridTemplatesData = parseGridTemplatesData(css); // return undefined if no declarations found\n\n  if (gridTemplatesData.length === 0) {\n    return undefined;\n  } // we need to store the rules that we will insert later\n\n\n  var rulesToInsert = {};\n  css.walkDecls('grid-area', function (gridArea) {\n    var gridAreaRule = gridArea.parent;\n    var hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row';\n    var gridAreaMedia = getParentMedia(gridAreaRule);\n\n    if (isDisabled(gridArea)) {\n      return undefined;\n    }\n\n    var gridAreaRuleIndex = gridAreaMedia ? css.index(gridAreaMedia) : css.index(gridAreaRule);\n    var value = gridArea.value; // found the data that matches grid-area identifier\n\n    var data = gridTemplatesData.filter(function (d) {\n      return d.allAreas.includes(value);\n    })[0];\n\n    if (!data) {\n      return true;\n    }\n\n    var lastArea = data.allAreas[data.allAreas.length - 1];\n    var selectorBySpace = list.space(gridAreaRule.selector);\n    var selectorByComma = list.comma(gridAreaRule.selector);\n    var selectorIsComplex = selectorBySpace.length > 1 && selectorBySpace.length > selectorByComma.length; // prevent doubling of prefixes\n\n    if (hasPrefixedRow) {\n      return false;\n    } // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n\n\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {};\n    }\n\n    var lastRuleIsSet = false; // walk through every grid-template rule data\n\n    for (var _iterator2 = data.rules, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref9;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref9 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref9 = _i2.value;\n      }\n\n      var rule = _ref9;\n      var area = rule.areas[value];\n      var hasDuplicateName = rule.duplicateAreaNames.includes(value); // if we can't find the area name, update lastRule and continue\n\n      if (!area) {\n        var lastRuleIndex = css.index(rulesToInsert[lastArea].lastRule);\n\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n        }\n\n        continue;\n      } // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n\n\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = [];\n      }\n\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n        getMSDecls(area, false, false).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n        rulesToInsert[lastArea].lastRule = gridAreaRule;\n        lastRuleIsSet = true;\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        (function () {\n          // grid-template has duplicates and not inside media rule\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n          cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n\n          if (rulesToInsert[lastArea].lastRule) {\n            rulesToInsert[lastArea].lastRule.after(cloned);\n          }\n\n          rulesToInsert[lastArea].lastRule = cloned;\n          lastRuleIsSet = true;\n        })();\n      } else if (rule.hasDuplicates && !rule.params && selectorIsComplex && gridAreaRule.selector.includes(rule.selectors[0])) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, function (d) {\n          return d.remove();\n        });\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n      } else if (rule.params) {\n        (function () {\n          // grid-template is inside media rule\n          // if we're inside media rule, we need to store prefixed rules\n          // inside rulesToInsert object to be able to preserve the order of media\n          // rules and merge them easily\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n\n          if (rule.hasDuplicates && hasDuplicateName) {\n            cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n          }\n\n          cloned.raws = rule.node.raws;\n\n          if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n            // append the prefixed rules right inside media rule\n            // with grid-template\n            rule.node.parent.append(cloned);\n          } else {\n            // store the rule to insert later\n            rulesToInsert[lastArea][rule.params].push(cloned);\n          } // set new rule as last rule ONLY if we didn't set lastRule for\n          // this grid-area before\n\n\n          if (!lastRuleIsSet) {\n            rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n          }\n        })();\n      }\n    }\n\n    return undefined;\n  }); // append stored rules inside the media rules\n\n  Object.keys(rulesToInsert).forEach(function (area) {\n    var data = rulesToInsert[area];\n    var lastRule = data.lastRule;\n    Object.keys(data).reverse().filter(function (p) {\n      return p !== 'lastRule';\n    }).forEach(function (params) {\n      if (data[params].length > 0 && lastRule) {\n        lastRule.after({\n          name: 'media',\n          params: params\n        });\n        lastRule.next().append(data[params]);\n      }\n    });\n  });\n  return undefined;\n}\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnMissedAreas(areas, decl, result) {\n  var missed = Object.keys(areas);\n  decl.root().walkDecls('grid-area', function (gridArea) {\n    missed = missed.filter(function (e) {\n      return e !== gridArea.value;\n    });\n  });\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '));\n  }\n\n  return undefined;\n}\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  var rule = decl.parent;\n  var root = decl.root();\n  var duplicatesFound = false; // slice selector array. Remove the last part (for comparison)\n\n  var slicedSelectorArr = list.space(rule.selector).filter(function (str) {\n    return str !== '>';\n  }).slice(0, -1); // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n\n  if (slicedSelectorArr.length > 0) {\n    var gridTemplateFound = false;\n    var foundAreaSelector = null;\n    root.walkDecls(/grid-template(-areas)?$/, function (d) {\n      var parent = d.parent;\n      var templateSelectors = parent.selectors;\n\n      var _parseTemplate2 = parseTemplate({\n        decl: d,\n        gap: getGridGap(d)\n      }),\n          areas = _parseTemplate2.areas;\n\n      var hasArea = areas[decl.value]; // find the the matching selectors\n\n      for (var _iterator3 = templateSelectors, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref10;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref10 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref10 = _i3.value;\n        }\n\n        var tplSelector = _ref10;\n\n        if (gridTemplateFound) {\n          break;\n        }\n\n        var tplSelectorArr = list.space(tplSelector).filter(function (str) {\n          return str !== '>';\n        });\n        gridTemplateFound = tplSelectorArr.every(function (item, idx) {\n          return item === slicedSelectorArr[idx];\n        });\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true;\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector;\n      } // if we found the duplicate area with different selector\n\n\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true;\n      }\n\n      return undefined;\n    }); // warn user if we didn't find template\n\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(result, \"Autoprefixer cannot find a grid-template \" + (\"containing the duplicate grid-area \\\"\" + decl.value + \"\\\" \") + (\"with full selector matching: \" + slicedSelectorArr.join(' ')));\n    }\n  }\n}\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  var rule = decl.parent;\n  var decls = [];\n  rule.walkDecls(/^grid-(row|column)/, function (d) {\n    if (!/-end$/.test(d.prop) && !/^span/.test(d.value)) {\n      decls.push(d);\n    }\n  });\n\n  if (decls.length > 0) {\n    decls.forEach(function (d) {\n      d.warn(result, \"You already have a grid-area declaration present in the rule. \" + (\"You should use either grid-area or \" + d.prop + \", not both\"));\n    });\n  }\n\n  return undefined;\n} // Gap utils\n\n\nfunction getGridGap(decl) {\n  var gap = {}; // try to find gap\n\n  var testGap = /^(grid-)?((row|column)-)?gap$/;\n  decl.parent.walkDecls(testGap, function (_ref11) {\n    var prop = _ref11.prop,\n        value = _ref11.value;\n\n    if (/^(grid-)?gap$/.test(prop)) {\n      var _parser$nodes = parser(value).nodes,\n          row = _parser$nodes[0],\n          column = _parser$nodes[2];\n      gap.row = row && parser.stringify(row);\n      gap.column = column ? parser.stringify(column) : gap.row;\n    }\n\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value;\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value;\n  });\n  return gap;\n}\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\n\n\nfunction parseMediaParams(params) {\n  if (!params) {\n    return false;\n  }\n\n  var parsed = parser(params);\n  var prop;\n  var value;\n  parsed.walk(function (node) {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value;\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''));\n    }\n  });\n  return [prop, value];\n}\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\n\n\nfunction shouldInheritGap(selA, selB) {\n  var result; // get arrays of selector split in 3-deep array\n\n  var splitSelectorArrA = splitSelector(selA);\n  var splitSelectorArrB = splitSelector(selB);\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false;\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n    var idx = splitSelectorArrA[0].reduce(function (res, _ref12, index) {\n      var item = _ref12[0];\n      var firstSelectorPart = splitSelectorArrB[0][0][0];\n\n      if (item === firstSelectorPart) {\n        return index;\n      }\n\n      return false;\n    }, false);\n\n    if (idx) {\n      result = splitSelectorArrB[0].every(function (arr, index) {\n        return arr.every(function (part, innerIndex) {\n          return (// because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n          );\n        });\n      });\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(function (byCommaArr) {\n      return byCommaArr.every(function (bySpaceArr, index) {\n        return bySpaceArr.every(function (part, innerIndex) {\n          return splitSelectorArrA[0][index][innerIndex] === part;\n        });\n      });\n    });\n  }\n\n  return result;\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\n\n\nfunction inheritGridGap(decl, gap) {\n  var rule = decl.parent;\n  var mediaRule = getParentMedia(rule);\n  var root = rule.root(); // get an array of selector split in 3-deep array\n\n  var splitSelectorArr = splitSelector(rule.selector); // abort if the rule already has gaps\n\n  if (Object.keys(gap).length > 0) {\n    return false;\n  } // e.g ['min-width']\n\n\n  var _parseMediaParams = parseMediaParams(mediaRule.params),\n      prop = _parseMediaParams[0];\n\n  var lastBySpace = splitSelectorArr[0]; // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n\n  var escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);\n  var regexp = new RegExp(\"(\" + escaped + \"$)|(\" + escaped + \"[,.])\"); // find the closest rule with the same selector\n\n  var closestRuleGap;\n  root.walkRules(regexp, function (r) {\n    var gridGap; // abort if are checking the same rule\n\n    if (rule.toString() === r.toString()) {\n      return false;\n    } // find grid-gap values\n\n\n    r.walkDecls('grid-gap', function (d) {\n      return gridGap = getGridGap(d);\n    }); // skip rule without gaps\n\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true;\n    } // skip rules that should not be inherited from\n\n\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true;\n    }\n\n    var media = getParentMedia(r);\n\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      var propToCompare = parseMediaParams(media.params)[0];\n\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap;\n        return true;\n      }\n    } else {\n      closestRuleGap = gridGap;\n      return true;\n    }\n\n    return undefined;\n  }); // if we find the closest gap object\n\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap;\n  }\n\n  return false;\n}\n\nfunction warnGridGap(_ref13) {\n  var gap = _ref13.gap,\n      hasColumns = _ref13.hasColumns,\n      decl = _ref13.decl,\n      result = _ref13.result;\n  var hasBothGaps = gap.row && gap.column;\n\n  if (!hasColumns && (hasBothGaps || gap.column && !gap.row)) {\n    delete gap.column;\n    decl.warn(result, 'Can not implement grid-gap without grid-template-columns');\n  }\n}\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\n\n\nfunction normalizeRowColumn(str) {\n  var normalized = parser(str).nodes.reduce(function (result, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      var key = 'count';\n\n      var _node$nodes$reduce = node.nodes.reduce(function (acc, n) {\n        if (n.type === 'word' && key === 'count') {\n          acc[0] = Math.abs(parseInt(n.value));\n          return acc;\n        }\n\n        if (n.type === 'div' && n.value === ',') {\n          key = 'value';\n          return acc;\n        }\n\n        if (key === 'value') {\n          acc[1] += parser.stringify(n);\n        }\n\n        return acc;\n      }, [0, '']),\n          count = _node$nodes$reduce[0],\n          value = _node$nodes$reduce[1];\n\n      if (count) {\n        for (var i = 0; i < count; i++) {\n          result.push(value);\n        }\n      }\n\n      return result;\n    }\n\n    if (node.type === 'space') {\n      return result;\n    }\n\n    return result.concat(parser.stringify(node));\n  }, []);\n  return normalized;\n}\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\n\n\nfunction autoplaceGridItems(decl, result, gap, autoflowValue) {\n  if (autoflowValue === void 0) {\n    autoflowValue = 'row';\n  }\n\n  var parent = decl.parent;\n  var rowDecl = parent.nodes.find(function (i) {\n    return i.prop === 'grid-template-rows';\n  });\n  var rows = normalizeRowColumn(rowDecl.value);\n  var columns = normalizeRowColumn(decl.value); // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n\n  var filledRows = rows.map(function (_, rowIndex) {\n    return Array.from({\n      length: columns.length\n    }, function (v, k) {\n      return k + rowIndex * columns.length + 1;\n    }).join(' ');\n  });\n  var areas = parseGridAreas({\n    rows: filledRows,\n    gap: gap\n  });\n  var keys = Object.keys(areas);\n  var items = keys.map(function (i) {\n    return areas[i];\n  }); // Change the order of cells if grid-auto-flow value is 'column'\n\n  if (autoflowValue.includes('column')) {\n    items = items.sort(function (a, b) {\n      return a.column.start - b.column.start;\n    });\n  } // Insert new rules\n\n\n  items.reverse().forEach(function (item, index) {\n    var column = item.column,\n        row = item.row;\n    var nodeSelector = parent.selectors.map(function (sel) {\n      return sel + (\" > *:nth-child(\" + (keys.length - index) + \")\");\n    }).join(', '); // create new rule\n\n    var node = parent.clone().removeAll(); // change rule selector\n\n    node.selector = nodeSelector; // insert prefixed row/column values\n\n    node.append({\n      prop: '-ms-grid-row',\n      value: row.start\n    });\n    node.append({\n      prop: '-ms-grid-column',\n      value: column.start\n    }); // insert rule\n\n    parent.after(node);\n  });\n  return undefined;\n}\n\nmodule.exports = {\n  parse: parse,\n  translate: translate,\n  parseTemplate: parseTemplate,\n  parseGridAreas: parseGridAreas,\n  warnMissedAreas: warnMissedAreas,\n  insertAreas: insertAreas,\n  insertDecl: insertDecl,\n  prefixTrackProp: prefixTrackProp,\n  prefixTrackValue: prefixTrackValue,\n  getGridGap: getGridGap,\n  warnGridGap: warnGridGap,\n  warnTemplateSelectorNotFound: warnTemplateSelectorNotFound,\n  warnIfGridRowColumnExists: warnIfGridRowColumnExists,\n  inheritGridGap: inheritGridGap,\n  autoplaceGridItems: autoplaceGridItems\n};","map":{"version":3,"sources":["C:/Projects/Trunks/OWP-GIT/owp-fe/node_modules/autoprefixer/lib/hacks/grid-utils.js"],"names":["parser","require","list","uniq","escapeRegexp","splitSelector","convert","value","length","parseInt","translate","values","startIndex","endIndex","startValue","endValue","_convert","start","spanStart","_convert2","end","spanEnd","parse","decl","node","current","_iterator","nodes","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","i","type","push","insertDecl","prop","parent","some","cloneBefore","toString","prefixTrackProp","_ref2","prefix","replace","transformRepeat","_ref3","_ref4","gap","_nodes$reduce","reduce","result","key","stringify","size","count","_ret","filter","trim","val","_loop","forEach","item","index","v","join","prefixTrackValue","_ref5","concat","DOTS","track","span","getColumns","line","split","parseGridAreas","_ref6","rows","areas","rowIndex","row","area","columnIndex","test","column","_areas$area","Math","min","max","testTrack","verifyRowSize","parseTemplate","_ref7","gridTemplate","columns","getMSDecls","addRowSpan","addColumnSpan","String","getParentMedia","name","changeDuplicateAreaSelectors","ruleSelectors","templateSelectors","map","selector","selectorBySpace","space","selectorByComma","comma","slice","ruleSelector","newSelector","tplSelector","selectorsEqual","ruleA","ruleB","selectors","sel","s","parseGridTemplatesData","css","parsed","walkDecls","d","rule","media","getGridGap","inheritedGap","inheritGridGap","_parseTemplate","areaNames","Object","keys","acc","_ref8","idx","allAreas","hasAreas","includes","_parsed$index","rules","hasNoDuplicates","r","hasDuplicates","duplicatesFound","duplicateAreaNames","params","updateSpan","areasCount","duplicateRules","undefined","insertAreas","isDisabled","gridTemplatesData","rulesToInsert","gridArea","gridAreaRule","hasPrefixedRow","first","gridAreaMedia","gridAreaRuleIndex","data","lastArea","selectorIsComplex","lastRuleIsSet","_iterator2","_isArray2","_i2","_ref9","hasDuplicateName","lastRuleIndex","lastRule","reverse","prepend","assign","raws","between","cloned","clone","removeAll","after","remove","append","p","warnMissedAreas","missed","root","e","warn","warnTemplateSelectorNotFound","slicedSelectorArr","str","gridTemplateFound","foundAreaSelector","_parseTemplate2","hasArea","_iterator3","_isArray3","_i3","_ref10","tplSelectorArr","every","warnIfGridRowColumnExists","decls","testGap","_ref11","_parser$nodes","parseMediaParams","walk","shouldInheritGap","selA","selB","splitSelectorArrA","splitSelectorArrB","res","_ref12","firstSelectorPart","arr","part","innerIndex","byCommaArr","bySpaceArr","mediaRule","splitSelectorArr","_parseMediaParams","lastBySpace","escaped","regexp","RegExp","closestRuleGap","walkRules","gridGap","propToCompare","warnGridGap","_ref13","hasColumns","hasBothGaps","normalizeRowColumn","normalized","_node$nodes$reduce","n","abs","autoplaceGridItems","autoflowValue","rowDecl","find","filledRows","_","from","k","items","sort","a","b","nodeSelector","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar parser = require('postcss-value-parser');\n\nvar list = require('postcss').list;\n\nvar uniq = require('../utils').uniq;\n\nvar escapeRegexp = require('../utils').escapeRegexp;\n\nvar splitSelector = require('../utils').splitSelector;\n\nfunction convert(value) {\n  if (value && value.length === 2 && value[0] === 'span' && parseInt(value[1], 10) > 0) {\n    return [false, parseInt(value[1], 10)];\n  }\n\n  if (value && value.length === 1 && parseInt(value[0], 10) > 0) {\n    return [parseInt(value[0], 10), false];\n  }\n\n  return [false, false];\n}\n\nfunction translate(values, startIndex, endIndex) {\n  var startValue = values[startIndex];\n  var endValue = values[endIndex];\n\n  if (!startValue) {\n    return [false, false];\n  }\n\n  var _convert = convert(startValue),\n      start = _convert[0],\n      spanStart = _convert[1];\n\n  var _convert2 = convert(endValue),\n      end = _convert2[0],\n      spanEnd = _convert2[1];\n\n  if (start && !endValue) {\n    return [start, false];\n  }\n\n  if (spanStart && end) {\n    return [end - spanStart, spanStart];\n  }\n\n  if (start && spanEnd) {\n    return [start, spanEnd];\n  }\n\n  if (start && end) {\n    return [start, end - start];\n  }\n\n  return [false, false];\n}\n\nfunction parse(decl) {\n  var node = parser(decl.value);\n  var values = [];\n  var current = 0;\n  values[current] = [];\n\n  for (var _iterator = node.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var i = _ref;\n\n    if (i.type === 'div') {\n      current += 1;\n      values[current] = [];\n    } else if (i.type === 'word') {\n      values[current].push(i.value);\n    }\n  }\n\n  return values;\n}\n\nfunction insertDecl(decl, prop, value) {\n  if (value && !decl.parent.some(function (i) {\n    return i.prop === \"-ms-\" + prop;\n  })) {\n    decl.cloneBefore({\n      prop: \"-ms-\" + prop,\n      value: value.toString()\n    });\n  }\n} // Track transforms\n\n\nfunction prefixTrackProp(_ref2) {\n  var prop = _ref2.prop,\n      prefix = _ref2.prefix;\n  return prefix + prop.replace('template-', '');\n}\n\nfunction transformRepeat(_ref3, _ref4) {\n  var nodes = _ref3.nodes;\n  var gap = _ref4.gap;\n\n  var _nodes$reduce = nodes.reduce(function (result, node) {\n    if (node.type === 'div' && node.value === ',') {\n      result.key = 'size';\n    } else {\n      result[result.key].push(parser.stringify(node));\n    }\n\n    return result;\n  }, {\n    key: 'count',\n    size: [],\n    count: []\n  }),\n      count = _nodes$reduce.count,\n      size = _nodes$reduce.size; // insert gap values\n\n\n  if (gap) {\n    var _ret = function () {\n      size = size.filter(function (i) {\n        return i.trim();\n      });\n      var val = [];\n\n      var _loop = function _loop(i) {\n        size.forEach(function (item, index) {\n          if (index > 0 || i > 1) {\n            val.push(gap);\n          }\n\n          val.push(item);\n        });\n      };\n\n      for (var i = 1; i <= count; i++) {\n        _loop(i);\n      }\n\n      return {\n        v: val.join(' ')\n      };\n    }();\n\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n\n  return \"(\" + size.join('') + \")[\" + count.join('') + \"]\";\n}\n\nfunction prefixTrackValue(_ref5) {\n  var value = _ref5.value,\n      gap = _ref5.gap;\n  var result = parser(value).nodes.reduce(function (nodes, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      return nodes.concat({\n        type: 'word',\n        value: transformRepeat(node, {\n          gap: gap\n        })\n      });\n    }\n\n    if (gap && node.type === 'space') {\n      return nodes.concat({\n        type: 'space',\n        value: ' '\n      }, {\n        type: 'word',\n        value: gap\n      }, node);\n    }\n\n    return nodes.concat(node);\n  }, []);\n  return parser.stringify(result);\n} // Parse grid-template-areas\n\n\nvar DOTS = /^\\.+$/;\n\nfunction track(start, end) {\n  return {\n    start: start,\n    end: end,\n    span: end - start\n  };\n}\n\nfunction getColumns(line) {\n  return line.trim().split(/\\s+/g);\n}\n\nfunction parseGridAreas(_ref6) {\n  var rows = _ref6.rows,\n      gap = _ref6.gap;\n  return rows.reduce(function (areas, line, rowIndex) {\n    if (gap.row) rowIndex *= 2;\n    if (line.trim() === '') return areas;\n    getColumns(line).forEach(function (area, columnIndex) {\n      if (DOTS.test(area)) return;\n      if (gap.column) columnIndex *= 2;\n\n      if (typeof areas[area] === 'undefined') {\n        areas[area] = {\n          column: track(columnIndex + 1, columnIndex + 2),\n          row: track(rowIndex + 1, rowIndex + 2)\n        };\n      } else {\n        var _areas$area = areas[area],\n            column = _areas$area.column,\n            row = _areas$area.row;\n        column.start = Math.min(column.start, columnIndex + 1);\n        column.end = Math.max(column.end, columnIndex + 2);\n        column.span = column.end - column.start;\n        row.start = Math.min(row.start, rowIndex + 1);\n        row.end = Math.max(row.end, rowIndex + 2);\n        row.span = row.end - row.start;\n      }\n    });\n    return areas;\n  }, {});\n} // Parse grid-template\n\n\nfunction testTrack(node) {\n  return node.type === 'word' && /^\\[.+\\]$/.test(node.value);\n}\n\nfunction verifyRowSize(result) {\n  if (result.areas.length > result.rows.length) {\n    result.rows.push('auto');\n  }\n\n  return result;\n}\n\nfunction parseTemplate(_ref7) {\n  var decl = _ref7.decl,\n      gap = _ref7.gap;\n  var gridTemplate = parser(decl.value).nodes.reduce(function (result, node) {\n    var type = node.type,\n        value = node.value;\n    if (testTrack(node) || type === 'space') return result; // area\n\n    if (type === 'string') {\n      result = verifyRowSize(result);\n      result.areas.push(value);\n    } // values and function\n\n\n    if (type === 'word' || type === 'function') {\n      result[result.key].push(parser.stringify(node));\n    } // divider(/)\n\n\n    if (type === 'div' && value === '/') {\n      result.key = 'columns';\n      result = verifyRowSize(result);\n    }\n\n    return result;\n  }, {\n    key: 'rows',\n    columns: [],\n    rows: [],\n    areas: []\n  });\n  return {\n    areas: parseGridAreas({\n      rows: gridTemplate.areas,\n      gap: gap\n    }),\n    columns: prefixTrackValue({\n      value: gridTemplate.columns.join(' '),\n      gap: gap.column\n    }),\n    rows: prefixTrackValue({\n      value: gridTemplate.rows.join(' '),\n      gap: gap.row\n    })\n  };\n} // Insert parsed grid areas\n\n/**\n * Get an array of -ms- prefixed props and values\n * @param  {Object} [area] area object with column and row data\n * @param  {Boolean} [addRowSpan] should we add grid-column-row value?\n * @param  {Boolean} [addColumnSpan] should we add grid-column-span value?\n * @return {Array<Object>}\n */\n\n\nfunction getMSDecls(area, addRowSpan, addColumnSpan) {\n  if (addRowSpan === void 0) {\n    addRowSpan = false;\n  }\n\n  if (addColumnSpan === void 0) {\n    addColumnSpan = false;\n  }\n\n  return [].concat({\n    prop: '-ms-grid-row',\n    value: String(area.row.start)\n  }, area.row.span > 1 || addRowSpan ? {\n    prop: '-ms-grid-row-span',\n    value: String(area.row.span)\n  } : [], {\n    prop: '-ms-grid-column',\n    value: String(area.column.start)\n  }, area.column.span > 1 || addColumnSpan ? {\n    prop: '-ms-grid-column-span',\n    value: String(area.column.span)\n  } : []);\n}\n\nfunction getParentMedia(parent) {\n  if (parent.type === 'atrule' && parent.name === 'media') {\n    return parent;\n  }\n\n  if (!parent.parent) {\n    return false;\n  }\n\n  return getParentMedia(parent.parent);\n}\n/**\n * change selectors for rules with duplicate grid-areas.\n * @param  {Array<Rule>} rules\n * @param  {Array<String>} templateSelectors\n * @return {Array<Rule>} rules with changed selectors\n */\n\n\nfunction changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {\n  ruleSelectors = ruleSelectors.map(function (selector) {\n    var selectorBySpace = list.space(selector);\n    var selectorByComma = list.comma(selector);\n\n    if (selectorBySpace.length > selectorByComma.length) {\n      selector = selectorBySpace.slice(-1).join('');\n    }\n\n    return selector;\n  });\n  return ruleSelectors.map(function (ruleSelector) {\n    var newSelector = templateSelectors.map(function (tplSelector, index) {\n      var space = index === 0 ? '' : ' ';\n      return \"\" + space + tplSelector + \" > \" + ruleSelector;\n    });\n    return newSelector;\n  });\n}\n/**\n * check if selector of rules are equal\n * @param  {Rule} ruleA\n * @param  {Rule} ruleB\n * @return {Boolean}\n */\n\n\nfunction selectorsEqual(ruleA, ruleB) {\n  return ruleA.selectors.some(function (sel) {\n    return ruleB.selectors.some(function (s) {\n      return s === sel;\n    });\n  });\n}\n/**\n * Parse data from all grid-template(-areas) declarations\n * @param  {Root} css css root\n * @return {Object} parsed data\n */\n\n\nfunction parseGridTemplatesData(css) {\n  var parsed = []; // we walk through every grid-template(-areas) declaration and store\n  // data with the same area names inside the item\n\n  css.walkDecls(/grid-template(-areas)?$/, function (d) {\n    var rule = d.parent;\n    var media = getParentMedia(rule);\n    var gap = getGridGap(d);\n    var inheritedGap = inheritGridGap(d, gap);\n\n    var _parseTemplate = parseTemplate({\n      decl: d,\n      gap: inheritedGap || gap\n    }),\n        areas = _parseTemplate.areas;\n\n    var areaNames = Object.keys(areas); // skip node if it doesn't have areas\n\n    if (areaNames.length === 0) {\n      return true;\n    } // check parsed array for item that include the same area names\n    // return index of that item\n\n\n    var index = parsed.reduce(function (acc, _ref8, idx) {\n      var allAreas = _ref8.allAreas;\n      var hasAreas = allAreas && areaNames.some(function (area) {\n        return allAreas.includes(area);\n      });\n      return hasAreas ? idx : acc;\n    }, null);\n\n    if (index !== null) {\n      // index is found, add the grid-template data to that item\n      var _parsed$index = parsed[index],\n          allAreas = _parsed$index.allAreas,\n          rules = _parsed$index.rules; // check if rule has no duplicate area names\n\n      var hasNoDuplicates = rules.some(function (r) {\n        return r.hasDuplicates === false && selectorsEqual(r, rule);\n      });\n      var duplicatesFound = false; // check need to gather all duplicate area names\n\n      var duplicateAreaNames = rules.reduce(function (acc, r) {\n        if (!r.params && selectorsEqual(r, rule)) {\n          duplicatesFound = true;\n          return r.duplicateAreaNames;\n        }\n\n        if (!duplicatesFound) {\n          areaNames.forEach(function (name) {\n            if (r.areas[name]) {\n              acc.push(name);\n            }\n          });\n        }\n\n        return uniq(acc);\n      }, []); // update grid-row/column-span values for areas with duplicate\n      // area names. @see #1084 and #1146\n\n      rules.forEach(function (r) {\n        areaNames.forEach(function (name) {\n          var area = r.areas[name];\n\n          if (area && area.row.span !== areas[name].row.span) {\n            areas[name].row.updateSpan = true;\n          }\n\n          if (area && area.column.span !== areas[name].column.span) {\n            areas[name].column.updateSpan = true;\n          }\n        });\n      });\n      parsed[index].allAreas = uniq([].concat(allAreas, areaNames));\n      parsed[index].rules.push({\n        hasDuplicates: !hasNoDuplicates,\n        params: media.params,\n        selectors: rule.selectors,\n        node: rule,\n        duplicateAreaNames: duplicateAreaNames,\n        areas: areas\n      });\n    } else {\n      // index is NOT found, push the new item to the parsed array\n      parsed.push({\n        allAreas: areaNames,\n        areasCount: 0,\n        rules: [{\n          hasDuplicates: false,\n          duplicateRules: [],\n          params: media.params,\n          selectors: rule.selectors,\n          node: rule,\n          duplicateAreaNames: [],\n          areas: areas\n        }]\n      });\n    }\n\n    return undefined;\n  });\n  return parsed;\n}\n/**\n * insert prefixed grid-area declarations\n * @param  {Root}  css css root\n * @param  {Function} isDisabled check if the rule is disabled\n * @return {void}\n */\n\n\nfunction insertAreas(css, isDisabled) {\n  // parse grid-template declarations\n  var gridTemplatesData = parseGridTemplatesData(css); // return undefined if no declarations found\n\n  if (gridTemplatesData.length === 0) {\n    return undefined;\n  } // we need to store the rules that we will insert later\n\n\n  var rulesToInsert = {};\n  css.walkDecls('grid-area', function (gridArea) {\n    var gridAreaRule = gridArea.parent;\n    var hasPrefixedRow = gridAreaRule.first.prop === '-ms-grid-row';\n    var gridAreaMedia = getParentMedia(gridAreaRule);\n\n    if (isDisabled(gridArea)) {\n      return undefined;\n    }\n\n    var gridAreaRuleIndex = gridAreaMedia ? css.index(gridAreaMedia) : css.index(gridAreaRule);\n    var value = gridArea.value; // found the data that matches grid-area identifier\n\n    var data = gridTemplatesData.filter(function (d) {\n      return d.allAreas.includes(value);\n    })[0];\n\n    if (!data) {\n      return true;\n    }\n\n    var lastArea = data.allAreas[data.allAreas.length - 1];\n    var selectorBySpace = list.space(gridAreaRule.selector);\n    var selectorByComma = list.comma(gridAreaRule.selector);\n    var selectorIsComplex = selectorBySpace.length > 1 && selectorBySpace.length > selectorByComma.length; // prevent doubling of prefixes\n\n    if (hasPrefixedRow) {\n      return false;\n    } // create the empty object with the key as the last area name\n    // e.g if we have templates with \"a b c\" values, \"c\" will be the last area\n\n\n    if (!rulesToInsert[lastArea]) {\n      rulesToInsert[lastArea] = {};\n    }\n\n    var lastRuleIsSet = false; // walk through every grid-template rule data\n\n    for (var _iterator2 = data.rules, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref9;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref9 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref9 = _i2.value;\n      }\n\n      var rule = _ref9;\n      var area = rule.areas[value];\n      var hasDuplicateName = rule.duplicateAreaNames.includes(value); // if we can't find the area name, update lastRule and continue\n\n      if (!area) {\n        var lastRuleIndex = css.index(rulesToInsert[lastArea].lastRule);\n\n        if (gridAreaRuleIndex > lastRuleIndex) {\n          rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n        }\n\n        continue;\n      } // for grid-templates inside media rule we need to create empty\n      // array to push prefixed grid-area rules later\n\n\n      if (rule.params && !rulesToInsert[lastArea][rule.params]) {\n        rulesToInsert[lastArea][rule.params] = [];\n      }\n\n      if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {\n        // grid-template has no duplicates and not inside media rule\n        getMSDecls(area, false, false).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n        rulesToInsert[lastArea].lastRule = gridAreaRule;\n        lastRuleIsSet = true;\n      } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {\n        (function () {\n          // grid-template has duplicates and not inside media rule\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n          cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n\n          if (rulesToInsert[lastArea].lastRule) {\n            rulesToInsert[lastArea].lastRule.after(cloned);\n          }\n\n          rulesToInsert[lastArea].lastRule = cloned;\n          lastRuleIsSet = true;\n        })();\n      } else if (rule.hasDuplicates && !rule.params && selectorIsComplex && gridAreaRule.selector.includes(rule.selectors[0])) {\n        // grid-template has duplicates and not inside media rule\n        // and the selector is complex\n        gridAreaRule.walkDecls(/-ms-grid-(row|column)/, function (d) {\n          return d.remove();\n        });\n        getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n          return gridAreaRule.prepend(Object.assign(i, {\n            raws: {\n              between: gridArea.raws.between\n            }\n          }));\n        });\n      } else if (rule.params) {\n        (function () {\n          // grid-template is inside media rule\n          // if we're inside media rule, we need to store prefixed rules\n          // inside rulesToInsert object to be able to preserve the order of media\n          // rules and merge them easily\n          var cloned = gridAreaRule.clone();\n          cloned.removeAll();\n          getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(function (i) {\n            return cloned.prepend(Object.assign(i, {\n              raws: {\n                between: gridArea.raws.between\n              }\n            }));\n          });\n\n          if (rule.hasDuplicates && hasDuplicateName) {\n            cloned.selectors = changeDuplicateAreaSelectors(cloned.selectors, rule.selectors);\n          }\n\n          cloned.raws = rule.node.raws;\n\n          if (css.index(rule.node.parent) > gridAreaRuleIndex) {\n            // append the prefixed rules right inside media rule\n            // with grid-template\n            rule.node.parent.append(cloned);\n          } else {\n            // store the rule to insert later\n            rulesToInsert[lastArea][rule.params].push(cloned);\n          } // set new rule as last rule ONLY if we didn't set lastRule for\n          // this grid-area before\n\n\n          if (!lastRuleIsSet) {\n            rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;\n          }\n        })();\n      }\n    }\n\n    return undefined;\n  }); // append stored rules inside the media rules\n\n  Object.keys(rulesToInsert).forEach(function (area) {\n    var data = rulesToInsert[area];\n    var lastRule = data.lastRule;\n    Object.keys(data).reverse().filter(function (p) {\n      return p !== 'lastRule';\n    }).forEach(function (params) {\n      if (data[params].length > 0 && lastRule) {\n        lastRule.after({\n          name: 'media',\n          params: params\n        });\n        lastRule.next().append(data[params]);\n      }\n    });\n  });\n  return undefined;\n}\n/**\n * Warn user if grid area identifiers are not found\n * @param  {Object} areas\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnMissedAreas(areas, decl, result) {\n  var missed = Object.keys(areas);\n  decl.root().walkDecls('grid-area', function (gridArea) {\n    missed = missed.filter(function (e) {\n      return e !== gridArea.value;\n    });\n  });\n\n  if (missed.length > 0) {\n    decl.warn(result, 'Can not find grid areas: ' + missed.join(', '));\n  }\n\n  return undefined;\n}\n/**\n * compare selectors with grid-area rule and grid-template rule\n * show warning if grid-template selector is not found\n * (this function used for grid-area rule)\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnTemplateSelectorNotFound(decl, result) {\n  var rule = decl.parent;\n  var root = decl.root();\n  var duplicatesFound = false; // slice selector array. Remove the last part (for comparison)\n\n  var slicedSelectorArr = list.space(rule.selector).filter(function (str) {\n    return str !== '>';\n  }).slice(0, -1); // we need to compare only if selector is complex.\n  // e.g '.grid-cell' is simple, but '.parent > .grid-cell' is complex\n\n  if (slicedSelectorArr.length > 0) {\n    var gridTemplateFound = false;\n    var foundAreaSelector = null;\n    root.walkDecls(/grid-template(-areas)?$/, function (d) {\n      var parent = d.parent;\n      var templateSelectors = parent.selectors;\n\n      var _parseTemplate2 = parseTemplate({\n        decl: d,\n        gap: getGridGap(d)\n      }),\n          areas = _parseTemplate2.areas;\n\n      var hasArea = areas[decl.value]; // find the the matching selectors\n\n      for (var _iterator3 = templateSelectors, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref10;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref10 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref10 = _i3.value;\n        }\n\n        var tplSelector = _ref10;\n\n        if (gridTemplateFound) {\n          break;\n        }\n\n        var tplSelectorArr = list.space(tplSelector).filter(function (str) {\n          return str !== '>';\n        });\n        gridTemplateFound = tplSelectorArr.every(function (item, idx) {\n          return item === slicedSelectorArr[idx];\n        });\n      }\n\n      if (gridTemplateFound || !hasArea) {\n        return true;\n      }\n\n      if (!foundAreaSelector) {\n        foundAreaSelector = parent.selector;\n      } // if we found the duplicate area with different selector\n\n\n      if (foundAreaSelector && foundAreaSelector !== parent.selector) {\n        duplicatesFound = true;\n      }\n\n      return undefined;\n    }); // warn user if we didn't find template\n\n    if (!gridTemplateFound && duplicatesFound) {\n      decl.warn(result, \"Autoprefixer cannot find a grid-template \" + (\"containing the duplicate grid-area \\\"\" + decl.value + \"\\\" \") + (\"with full selector matching: \" + slicedSelectorArr.join(' ')));\n    }\n  }\n}\n/**\n * warn user if both grid-area and grid-(row|column)\n * declarations are present in the same rule\n * @param  {Declaration} decl\n * @param  {Result} result\n * @return {void}\n */\n\n\nfunction warnIfGridRowColumnExists(decl, result) {\n  var rule = decl.parent;\n  var decls = [];\n  rule.walkDecls(/^grid-(row|column)/, function (d) {\n    if (!/-end$/.test(d.prop) && !/^span/.test(d.value)) {\n      decls.push(d);\n    }\n  });\n\n  if (decls.length > 0) {\n    decls.forEach(function (d) {\n      d.warn(result, \"You already have a grid-area declaration present in the rule. \" + (\"You should use either grid-area or \" + d.prop + \", not both\"));\n    });\n  }\n\n  return undefined;\n} // Gap utils\n\n\nfunction getGridGap(decl) {\n  var gap = {}; // try to find gap\n\n  var testGap = /^(grid-)?((row|column)-)?gap$/;\n  decl.parent.walkDecls(testGap, function (_ref11) {\n    var prop = _ref11.prop,\n        value = _ref11.value;\n\n    if (/^(grid-)?gap$/.test(prop)) {\n      var _parser$nodes = parser(value).nodes,\n          row = _parser$nodes[0],\n          column = _parser$nodes[2];\n      gap.row = row && parser.stringify(row);\n      gap.column = column ? parser.stringify(column) : gap.row;\n    }\n\n    if (/^(grid-)?row-gap$/.test(prop)) gap.row = value;\n    if (/^(grid-)?column-gap$/.test(prop)) gap.column = value;\n  });\n  return gap;\n}\n/**\n * parse media parameters (for example 'min-width: 500px')\n * @param  {String} params parameter to parse\n * @return {}\n */\n\n\nfunction parseMediaParams(params) {\n  if (!params) {\n    return false;\n  }\n\n  var parsed = parser(params);\n  var prop;\n  var value;\n  parsed.walk(function (node) {\n    if (node.type === 'word' && /min|max/g.test(node.value)) {\n      prop = node.value;\n    } else if (node.value.includes('px')) {\n      value = parseInt(node.value.replace(/\\D/g, ''));\n    }\n  });\n  return [prop, value];\n}\n/**\n * Compare the selectors and decide if we\n * need to inherit gap from compared selector or not.\n * @type {String} selA\n * @type {String} selB\n * @return {Boolean}\n */\n\n\nfunction shouldInheritGap(selA, selB) {\n  var result; // get arrays of selector split in 3-deep array\n\n  var splitSelectorArrA = splitSelector(selA);\n  var splitSelectorArrB = splitSelector(selB);\n\n  if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {\n    // abort if selectorA has lower descendant specificity then selectorB\n    // (e.g '.grid' and '.hello .world .grid')\n    return false;\n  } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {\n    // if selectorA has higher descendant specificity then selectorB\n    // (e.g '.foo .bar .grid' and '.grid')\n    var idx = splitSelectorArrA[0].reduce(function (res, _ref12, index) {\n      var item = _ref12[0];\n      var firstSelectorPart = splitSelectorArrB[0][0][0];\n\n      if (item === firstSelectorPart) {\n        return index;\n      }\n\n      return false;\n    }, false);\n\n    if (idx) {\n      result = splitSelectorArrB[0].every(function (arr, index) {\n        return arr.every(function (part, innerIndex) {\n          return (// because selectorA has more space elements, we need to slice\n            // selectorA array by 'idx' number to compare them\n            splitSelectorArrA[0].slice(idx)[index][innerIndex] === part\n          );\n        });\n      });\n    }\n  } else {\n    // if selectorA has the same descendant specificity as selectorB\n    // this condition covers cases such as: '.grid.foo.bar' and '.grid'\n    result = splitSelectorArrB.some(function (byCommaArr) {\n      return byCommaArr.every(function (bySpaceArr, index) {\n        return bySpaceArr.every(function (part, innerIndex) {\n          return splitSelectorArrA[0][index][innerIndex] === part;\n        });\n      });\n    });\n  }\n\n  return result;\n}\n/**\n * inherit grid gap values from the closest rule above\n * with the same selector\n * @param  {Declaration} decl\n * @param  {Object} gap gap values\n * @return {Object | Boolean} return gap values or false (if not found)\n */\n\n\nfunction inheritGridGap(decl, gap) {\n  var rule = decl.parent;\n  var mediaRule = getParentMedia(rule);\n  var root = rule.root(); // get an array of selector split in 3-deep array\n\n  var splitSelectorArr = splitSelector(rule.selector); // abort if the rule already has gaps\n\n  if (Object.keys(gap).length > 0) {\n    return false;\n  } // e.g ['min-width']\n\n\n  var _parseMediaParams = parseMediaParams(mediaRule.params),\n      prop = _parseMediaParams[0];\n\n  var lastBySpace = splitSelectorArr[0]; // get escaped value from the selector\n  // if we have '.grid-2.foo.bar' selector, will be '\\.grid\\-2'\n\n  var escaped = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);\n  var regexp = new RegExp(\"(\" + escaped + \"$)|(\" + escaped + \"[,.])\"); // find the closest rule with the same selector\n\n  var closestRuleGap;\n  root.walkRules(regexp, function (r) {\n    var gridGap; // abort if are checking the same rule\n\n    if (rule.toString() === r.toString()) {\n      return false;\n    } // find grid-gap values\n\n\n    r.walkDecls('grid-gap', function (d) {\n      return gridGap = getGridGap(d);\n    }); // skip rule without gaps\n\n    if (!gridGap || Object.keys(gridGap).length === 0) {\n      return true;\n    } // skip rules that should not be inherited from\n\n\n    if (!shouldInheritGap(rule.selector, r.selector)) {\n      return true;\n    }\n\n    var media = getParentMedia(r);\n\n    if (media) {\n      // if we are inside media, we need to check that media props match\n      // e.g ('min-width' === 'min-width')\n      var propToCompare = parseMediaParams(media.params)[0];\n\n      if (propToCompare === prop) {\n        closestRuleGap = gridGap;\n        return true;\n      }\n    } else {\n      closestRuleGap = gridGap;\n      return true;\n    }\n\n    return undefined;\n  }); // if we find the closest gap object\n\n  if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {\n    return closestRuleGap;\n  }\n\n  return false;\n}\n\nfunction warnGridGap(_ref13) {\n  var gap = _ref13.gap,\n      hasColumns = _ref13.hasColumns,\n      decl = _ref13.decl,\n      result = _ref13.result;\n  var hasBothGaps = gap.row && gap.column;\n\n  if (!hasColumns && (hasBothGaps || gap.column && !gap.row)) {\n    delete gap.column;\n    decl.warn(result, 'Can not implement grid-gap without grid-template-columns');\n  }\n}\n/**\n * normalize the grid-template-rows/columns values\n * @param  {String} str grid-template-rows/columns value\n * @return {Array} normalized array with values\n * @example\n * let normalized = normalizeRowColumn('1fr repeat(2, 20px 50px) 1fr')\n * normalized // <= ['1fr', '20px', '50px', '20px', '50px', '1fr']\n */\n\n\nfunction normalizeRowColumn(str) {\n  var normalized = parser(str).nodes.reduce(function (result, node) {\n    if (node.type === 'function' && node.value === 'repeat') {\n      var key = 'count';\n\n      var _node$nodes$reduce = node.nodes.reduce(function (acc, n) {\n        if (n.type === 'word' && key === 'count') {\n          acc[0] = Math.abs(parseInt(n.value));\n          return acc;\n        }\n\n        if (n.type === 'div' && n.value === ',') {\n          key = 'value';\n          return acc;\n        }\n\n        if (key === 'value') {\n          acc[1] += parser.stringify(n);\n        }\n\n        return acc;\n      }, [0, '']),\n          count = _node$nodes$reduce[0],\n          value = _node$nodes$reduce[1];\n\n      if (count) {\n        for (var i = 0; i < count; i++) {\n          result.push(value);\n        }\n      }\n\n      return result;\n    }\n\n    if (node.type === 'space') {\n      return result;\n    }\n\n    return result.concat(parser.stringify(node));\n  }, []);\n  return normalized;\n}\n/**\n * Autoplace grid items\n * @param {Declaration} decl\n * @param {Result} result\n * @param {Object} gap gap values\n * @param {String} autoflowValue grid-auto-flow value\n * @return {void}\n * @see https://github.com/postcss/autoprefixer/issues/1148\n */\n\n\nfunction autoplaceGridItems(decl, result, gap, autoflowValue) {\n  if (autoflowValue === void 0) {\n    autoflowValue = 'row';\n  }\n\n  var parent = decl.parent;\n  var rowDecl = parent.nodes.find(function (i) {\n    return i.prop === 'grid-template-rows';\n  });\n  var rows = normalizeRowColumn(rowDecl.value);\n  var columns = normalizeRowColumn(decl.value); // Build array of area names with dummy values. If we have 3 columns and\n  // 2 rows, filledRows will be equal to ['1 2 3', '4 5 6']\n\n  var filledRows = rows.map(function (_, rowIndex) {\n    return Array.from({\n      length: columns.length\n    }, function (v, k) {\n      return k + rowIndex * columns.length + 1;\n    }).join(' ');\n  });\n  var areas = parseGridAreas({\n    rows: filledRows,\n    gap: gap\n  });\n  var keys = Object.keys(areas);\n  var items = keys.map(function (i) {\n    return areas[i];\n  }); // Change the order of cells if grid-auto-flow value is 'column'\n\n  if (autoflowValue.includes('column')) {\n    items = items.sort(function (a, b) {\n      return a.column.start - b.column.start;\n    });\n  } // Insert new rules\n\n\n  items.reverse().forEach(function (item, index) {\n    var column = item.column,\n        row = item.row;\n    var nodeSelector = parent.selectors.map(function (sel) {\n      return sel + (\" > *:nth-child(\" + (keys.length - index) + \")\");\n    }).join(', '); // create new rule\n\n    var node = parent.clone().removeAll(); // change rule selector\n\n    node.selector = nodeSelector; // insert prefixed row/column values\n\n    node.append({\n      prop: '-ms-grid-row',\n      value: row.start\n    });\n    node.append({\n      prop: '-ms-grid-column',\n      value: column.start\n    }); // insert rule\n\n    parent.after(node);\n  });\n  return undefined;\n}\n\nmodule.exports = {\n  parse: parse,\n  translate: translate,\n  parseTemplate: parseTemplate,\n  parseGridAreas: parseGridAreas,\n  warnMissedAreas: warnMissedAreas,\n  insertAreas: insertAreas,\n  insertDecl: insertDecl,\n  prefixTrackProp: prefixTrackProp,\n  prefixTrackValue: prefixTrackValue,\n  getGridGap: getGridGap,\n  warnGridGap: warnGridGap,\n  warnTemplateSelectorNotFound: warnTemplateSelectorNotFound,\n  warnIfGridRowColumnExists: warnIfGridRowColumnExists,\n  inheritGridGap: inheritGridGap,\n  autoplaceGridItems: autoplaceGridItems\n};"]},"metadata":{},"sourceType":"script"}