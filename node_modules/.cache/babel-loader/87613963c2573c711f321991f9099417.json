{"ast":null,"code":"\"use strict\";\n\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n\n  return obj;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _defaults(subClass, superClass);\n}\n\nvar OldSelector = require('./old-selector');\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Selector = /*#__PURE__*/function (_Prefixer) {\n  _inheritsLoose(Selector, _Prefixer);\n\n  function Selector(name, prefixes, all) {\n    var _this;\n\n    _this = _Prefixer.call(this, name, prefixes, all) || this;\n    _this.regexpCache = {};\n    return _this;\n  }\n  /**\n     * Is rule selectors need to be prefixed\n     */\n\n\n  var _proto = Selector.prototype;\n\n  _proto.check = function check(rule) {\n    if (rule.selector.indexOf(this.name) !== -1) {\n      return !!rule.selector.match(this.regexp());\n    }\n\n    return false;\n  }\n  /**\n     * Return prefixed version of selector\n     */\n  ;\n\n  _proto.prefixed = function prefixed(prefix) {\n    return this.name.replace(/^([^\\w]*)/, \"$1\" + prefix);\n  }\n  /**\n     * Lazy loadRegExp for name\n     */\n  ;\n\n  _proto.regexp = function regexp(prefix) {\n    if (this.regexpCache[prefix]) {\n      return this.regexpCache[prefix];\n    }\n\n    var name = prefix ? this.prefixed(prefix) : this.name;\n    this.regexpCache[prefix] = new RegExp(\"(^|[^:\\\"'=])\" + utils.escapeRegexp(name), 'gi');\n    return this.regexpCache[prefix];\n  }\n  /**\n     * All possible prefixes\n     */\n  ;\n\n  _proto.possible = function possible() {\n    return Browsers.prefixes();\n  }\n  /**\n     * Return all possible selector prefixes\n     */\n  ;\n\n  _proto.prefixeds = function prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      return rule._autoprefixerPrefixeds;\n    }\n\n    var prefixeds = {};\n\n    for (var _iterator = this.possible(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var prefix = _ref;\n      prefixeds[prefix] = this.replace(rule.selector, prefix);\n    }\n\n    rule._autoprefixerPrefixeds = prefixeds;\n    return rule._autoprefixerPrefixeds;\n  }\n  /**\n     * Is rule already prefixed before\n     */\n  ;\n\n  _proto.already = function already(rule, prefixeds, prefix) {\n    var index = rule.parent.index(rule) - 1;\n\n    while (index >= 0) {\n      var before = rule.parent.nodes[index];\n\n      if (before.type !== 'rule') {\n        return false;\n      }\n\n      var some = false;\n\n      for (var key in prefixeds) {\n        var prefixed = prefixeds[key];\n\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true;\n          } else {\n            some = true;\n            break;\n          }\n        }\n      }\n\n      if (!some) {\n        return false;\n      }\n\n      index -= 1;\n    }\n\n    return false;\n  }\n  /**\n     * Replace selectors by prefixed one\n     */\n  ;\n\n  _proto.replace = function replace(selector, prefix) {\n    return selector.replace(this.regexp(), \"$1\" + this.prefixed(prefix));\n  }\n  /**\n     * Clone and add prefixes for at-rule\n     */\n  ;\n\n  _proto.add = function add(rule, prefix) {\n    var prefixeds = this.prefixeds(rule);\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return;\n    }\n\n    var cloned = this.clone(rule, {\n      selector: prefixeds[prefix]\n    });\n    rule.parent.insertBefore(rule, cloned);\n  }\n  /**\n     * Return function to fast find prefixed selector\n     */\n  ;\n\n  _proto.old = function old(prefix) {\n    return new OldSelector(this, prefix);\n  };\n\n  return Selector;\n}(Prefixer);\n\nmodule.exports = Selector;","map":{"version":3,"sources":["C:/Projects/Trunks/OWP-GIT/owp-fe/node_modules/autoprefixer/lib/selector.js"],"names":["_defaults","obj","defaults","keys","Object","getOwnPropertyNames","i","length","key","value","getOwnPropertyDescriptor","configurable","undefined","defineProperty","_inheritsLoose","subClass","superClass","prototype","create","constructor","OldSelector","require","Prefixer","Browsers","utils","Selector","_Prefixer","name","prefixes","all","_this","call","regexpCache","_proto","check","rule","selector","indexOf","match","regexp","prefixed","prefix","replace","RegExp","escapeRegexp","possible","prefixeds","_autoprefixerPrefixeds","_iterator","_isArray","Array","isArray","_i","Symbol","iterator","_ref","next","done","already","index","parent","before","nodes","type","some","add","cloned","clone","insertBefore","old","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _defaults(subClass, superClass); }\n\nvar OldSelector = require('./old-selector');\n\nvar Prefixer = require('./prefixer');\n\nvar Browsers = require('./browsers');\n\nvar utils = require('./utils');\n\nvar Selector =\n/*#__PURE__*/\nfunction (_Prefixer) {\n  _inheritsLoose(Selector, _Prefixer);\n\n  function Selector(name, prefixes, all) {\n    var _this;\n\n    _this = _Prefixer.call(this, name, prefixes, all) || this;\n    _this.regexpCache = {};\n    return _this;\n  }\n  /**\n     * Is rule selectors need to be prefixed\n     */\n\n\n  var _proto = Selector.prototype;\n\n  _proto.check = function check(rule) {\n    if (rule.selector.indexOf(this.name) !== -1) {\n      return !!rule.selector.match(this.regexp());\n    }\n\n    return false;\n  }\n  /**\n     * Return prefixed version of selector\n     */\n  ;\n\n  _proto.prefixed = function prefixed(prefix) {\n    return this.name.replace(/^([^\\w]*)/, \"$1\" + prefix);\n  }\n  /**\n     * Lazy loadRegExp for name\n     */\n  ;\n\n  _proto.regexp = function regexp(prefix) {\n    if (this.regexpCache[prefix]) {\n      return this.regexpCache[prefix];\n    }\n\n    var name = prefix ? this.prefixed(prefix) : this.name;\n    this.regexpCache[prefix] = new RegExp(\"(^|[^:\\\"'=])\" + utils.escapeRegexp(name), 'gi');\n    return this.regexpCache[prefix];\n  }\n  /**\n     * All possible prefixes\n     */\n  ;\n\n  _proto.possible = function possible() {\n    return Browsers.prefixes();\n  }\n  /**\n     * Return all possible selector prefixes\n     */\n  ;\n\n  _proto.prefixeds = function prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      return rule._autoprefixerPrefixeds;\n    }\n\n    var prefixeds = {};\n\n    for (var _iterator = this.possible(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var prefix = _ref;\n      prefixeds[prefix] = this.replace(rule.selector, prefix);\n    }\n\n    rule._autoprefixerPrefixeds = prefixeds;\n    return rule._autoprefixerPrefixeds;\n  }\n  /**\n     * Is rule already prefixed before\n     */\n  ;\n\n  _proto.already = function already(rule, prefixeds, prefix) {\n    var index = rule.parent.index(rule) - 1;\n\n    while (index >= 0) {\n      var before = rule.parent.nodes[index];\n\n      if (before.type !== 'rule') {\n        return false;\n      }\n\n      var some = false;\n\n      for (var key in prefixeds) {\n        var prefixed = prefixeds[key];\n\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true;\n          } else {\n            some = true;\n            break;\n          }\n        }\n      }\n\n      if (!some) {\n        return false;\n      }\n\n      index -= 1;\n    }\n\n    return false;\n  }\n  /**\n     * Replace selectors by prefixed one\n     */\n  ;\n\n  _proto.replace = function replace(selector, prefix) {\n    return selector.replace(this.regexp(), \"$1\" + this.prefixed(prefix));\n  }\n  /**\n     * Clone and add prefixes for at-rule\n     */\n  ;\n\n  _proto.add = function add(rule, prefix) {\n    var prefixeds = this.prefixeds(rule);\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return;\n    }\n\n    var cloned = this.clone(rule, {\n      selector: prefixeds[prefix]\n    });\n    rule.parent.insertBefore(rule, cloned);\n  }\n  /**\n     * Return function to fast find prefixed selector\n     */\n  ;\n\n  _proto.old = function old(prefix) {\n    return new OldSelector(this, prefix);\n  };\n\n  return Selector;\n}(Prefixer);\n\nmodule.exports = Selector;"]},"metadata":{},"sourceType":"script"}